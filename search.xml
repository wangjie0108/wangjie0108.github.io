<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[19年5月7日面试题（vue）]]></title>
    <url>%2F2019%2F05%2F07%2F19%E5%B9%B45%E6%9C%887%E6%97%A5%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88vue%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近面试的面试题，总结复盘，回答错的就更新，回答对了后期继续巩固，加油鸭！O(∩_∩)O哈哈~ 最近一直在面试，有很多时候会跑很远去面试，跑到地儿什么技术问题也没问，随便聊聊，然后就结束了，崩溃的就是不知道面试的啥？结束了?（黑人问号脸） 今晚是个电话面试，虽然可能得回答的不是很好，但是真的是在面试中找到自己的不足呀！(#^.^#) 谈谈对MVVM开发模式的理解 MVVM分为Model,View, ViewModel三者 Model：代表数据模型，数据和业务逻辑都在Model层定义； View：代表UI视图，负责数据的展示 ViewModel：负责监听Model中数据改变并且控制视图的更新，处理用户交互操作 Model和View并无直接联系，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此，当ViewModel中的数据改变时会触发View层的刷新。View中由于用户交互操作而改变的数据也会在Model中同步。 这种模式实现了Model和View的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要自己操作dom. vue响应式原理vue实例创建时，vue会遍历data选项的属性，用Object.definedProperty()将它们转化为getter/setter，并在内部追踪相关依赖，在属性被访问或修改时，通知变化；每个实例组件都用相对应的watcher程序实例，之后当相关依赖项的setter被调用时会通知watcher重新计算，从而致使它关联的组件得以更新 什么是虚拟DOM?用js对象的形式，来模拟页面的dom的嵌套关系 什么是框架?为什么使用框架?是一整套的解决方案，对项目的侵入性比较大，如果需要更换框架，则需要重新架构整个项目。使用框架可以快速开发，好的框架设计：松耦合，便于后期维护，减少多余的代码量。 如何优化SPA应用首屏加载慢速度慢的问题 将公用的JS库通过script标签外部引入，减少app.bundle的大小，让浏览器进行下载资源文件，提高下载速度； 在配置路由时，页面和组件使用懒加载的方式引入，进一步缩小app.bundle的体积，再调用某个组件时，再加载对应的js文件 加载一个首屏loading图，提升用户体验 前端如何优化网站性能 减少HTTP请求次数http通信进行通信。浏览器与服务器需要讲过三次握手，每次握手需要花费大量的时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发），一旦http请求数量达到一定数量，资源请求就存在等待状态，这是致命的，因此减少http请求数量可以很大程度上对网站性能进行优化 雪碧图 合并css和js 采用lazyLoad 控制资源文件加载优先级 浏览器在加载HTML内容时，是将HTML内容从上之下一次解析，解析到link或者script标签就会加载href或src对应链接的内容，为了第一时间暂时页面给用户，需要将css提前加载，不要受js加载影响 一般情况下，都是css放在头部，js放在底部 利用浏览器缓存 减少重排（Reflow） 基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会是渲染树中受到影响的部分失效，浏览器会验证DOM树上所有其他特点的visibility属性，这也是导致Reflow低效的原因，如果Reflow过于频繁，CPU使用率就会急剧上升。减少Reflow的过于频繁，如果需要在DOM操作时添加样式，尽量增加class属性，而不是通过style操作样式 减少DOM操作 图标使用IconFont替换 网页从输入到渲染过程完成经历了哪些过程？ 输入网址 发送DNS服务器，并获取域名对应的web服务器对应的ip地址； 与web服务器简历TCP链接 浏览器向web服务器发送http请求 web服务器响应请求，并返回指定的url数据（或错误信息，或重定向的新的url地址） 浏览器下载web服务器返回的数据及解析html源文件 生成DOM树， 解析css和js，渲染页面，直至显示完成 #router和route区别？router是VueRouter的实例，route相当于跳转的路由对象，在这个对象中可以获取到name path parama query webpack有什么用，以及一些常用配置？ js,css代码的压缩与合并 css预处理：less、scss的编译 生成雪碧图（css Sprite） ES6转化成ES5 模块化 … 常用配置 首先创建一个demo文件夹，使用过npm进行项目初始化： npm init 本地安装webpack，--save-dev会作为开发依赖来安装： npm install webpack --save-dev 安装webpack-dev-server,它可以提供很多服务，启动一个服务器，热更新，接口代理… npm install webpack-dev-server --save-dev 安装完毕，我们需要看一下是否安装成功，打开package.json文件，看一下devDependencies下包含webpack、webpack-dev-server,恭喜，安装成功了！ 归根结底，webpack就是一个JS文件，架构的好与差就体现在这个配置里，在demo文件夹下，创建一个webpack.config.js文件，初始化它的内容： 然后在package.json文件的script标签里增加一个快速启动webpack-dev-server服务的脚本： 此时运行npm run dev就会执行webpack-dev-server --open --config webpack.config.js的命令 webpack配置中最重要也是必选的两项是出入(Entry)和入口(Output).入口文件作用：告诉webpack从哪里开始寻找依赖，并且编译，出口则用来配置编译后的文件存储位置和文件名 在demo文件夹下创建一个空的入口文件main.js，然后在webpack.config.js中进行入口和输出的配置: 有了入口和出口，已经可以启动webpack项目了，在webpack世界里，每一个文件就是一个模块（.css,.js,.html,.jpg, .less），不同模块需要不同的加载器(Loaders)来处理，如CSS，需要style-loader和css-loader,安装： npm install css-loader --save-dev npm install style-loader --save-dev 安装完后在webpack.config.js中进行配置，增加对.css文件的处理： webpack功能很强大而且可以定制，使用extract-text-plugin的插件来把散落的css文件提取出来，生成main.css文件。 npm install extract-text-plugin --save-dev 未完待续吧…]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取路径]]></title>
    <url>%2F2018%2F12%2F01%2F%E8%8E%B7%E5%8F%96%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[如何获取地址栏中的参数 window.location.href location.href window.location decodeURI()可以解码地址栏中的数据，恢复中文数据 window.search获得地址栏中问号及问号之后的数据–获取地址栏里的参数（URL） 字符串拆分123456789101112131415161718192021function getRequest() &#123; // url例子：www.bicycle.com?id="123456"&amp;Name="bicycle"; var url = decodeURI(location.search); // ?id="123456"&amp;Name="bicycle" var object = &#123;&#125;; if (url.indexOf('?') != -1) &#123; // URL中存在？号，也就是说有参数 var str = url.substr(1); // 得到？后面的字符串 var newStr = str.split('&amp;'); // 将得到的参数分割成数组 [id="123456", Name="bicycle"] for (var i = 0; i &lt; newStr.length; i++) &#123; // 第一种判断方式 // var current = newStr[i].split('='); // if (current[0] == name) &#123; // return current[1]; // &#125; object[newStr[i].split('=')[0]] = newStr[i].split('=').[1]; &#125; &#125; return object[value];&#125; 正则匹配12345678function GetQueryString(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null; &#125; vue 在vue中可以通过this.$route获取路由对象然后根据具体需要取对象内容 this.$route.path 当前页面路由 this.$route.params 路由参数 this.$route.query 查询路由参数 jQuery实现页面跳转12345$(function() &#123; var keywords = $('#gotoPageNum').val(); // location.href 实现客户端页面的跳转 location.href = "newList.html?keywords="+keywords;&#125;) 清空页面内容及本地存储内容123456789&lt;!-- 储存的内容 --&gt;var keyArr = [];&lt;!-- 点击删除按钮清空内容 --&gt;$('#clearBtn').on('click', function () &#123; // 清空页面内容 $('#history').html(''); // 清除本地存储 localStorage.removeItem('keyArr')&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[今天遇到的谷歌控制台报错]]></title>
    <url>%2F2018%2F12%2F01%2F%E4%BB%8A%E5%A4%A9%E9%81%87%E5%88%B0%E7%9A%84%E8%B0%B7%E6%AD%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[日常小demo报错123456789&lt;script&gt; var busReserve = 1; var priReserve = 2; var J_reserveType = 1; if (!J_reserveType) return; if (J_reserveType) &#123; console.log('hah') &#125;&lt;/script&gt; 查看js手册发现，在js中return语句只能放在function中，如果不是在一个function中就会弹出如上错误；解决方法：只要把这个if语句放到一个函数中即可1234567891011&lt;script&gt; window.onload = function () &#123; var busReserve = 1; var priReserve = 2; var J_reserveType = 1; if (!J_reserveType) return; if (J_reserveType) &#123; console.log('hah') &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>报错</category>
      </categories>
      <tags>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react简单认识]]></title>
    <url>%2F2018%2F11%2F15%2Freact%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[react 与 vue 的对比组件化方面 什么是模块化是从代码的角度来进行分析的；把一些可复用的代码，抽离为单个模块；便于项目的维护和开发； 什么是组件化是从UI界面的角度来进行分析的，把一些可用的UI元素，抽离为单独的组件，便于项目的维护和开发 组件化的好处随着项目规模的增大，手里的组件越来越多；很方便就能把现有的组件，拼接为一个完整的页面 vue如何实现组件化的：通过.vue文件，创建对应的组件 template 结构 script 行为 style 样式 react如何实现组件化：react中有组件化的概念，但是，并没有像vue这样的组件模板文件；react中，一切都以js来表现的；因此，学习react，js，ES5和ES7(async 和 await)要会用； 移动APP开发方面 vue，结合Weex这门技术，提供了迁移到移动端APP开发的体验(Weex) react， 结合ReactNatve,也提供了无缝迁移到移动APP的开发体验(RN用的最多，也是最火最流行的) React中几个核心的概念虚拟DOM DOM的本质是什么：浏览器中的概念，用js对象来表示页面上的元素，并提供了DOM对象的API 什么是React中的虚拟DOM：是框架中的概念，是程序员用JS对象来模拟页面上的DOM和DOM嵌套； 为什么要实现虚拟DOM(虚拟DOM的目的)：为了实现页面中，DOM元素的高校更新 DOM和虚拟DOM的区别： DOM： 浏览器中，提供的概念；用js对象，表示页面上的元素，并提供了操作元素的API； 虚拟DOM：是框架中的概念；是开发框架的程序员，手动用js对象来模拟DOM元素个嵌套关系 本质：用js对象，来模拟DOM元素和嵌套关系； 目的：就是为了实现页面元素的高校更新； Diff 算法 tree diff：新旧两颗DOM树，逐层对比的过程，就是tree Diff;当整颗DOM逐层对比完毕，则所有需要被按需要更新的元素，必然能够找到； Component Diff:在进行tree diff的时候，每一层中，组件级别的对比，叫做Component Diff 如果对比前后，组件类型相同，则暂时认为次组件不需要被更新； 如果对比前后，组件类型不同，则需要移除组件，创建新的组件，并追加到页面上； element diff：在进行组件对比的时候，如果两个组件类型相同，则需要进行元素级别的对比，这叫做Element Diff; 创建基本的webpack4.X项目 运行npm init -y快速初始化项目 在项目根目录创建src源代码目录和dist产品目录 在src目录下创建index.html 使用cnpm安装webpack，运行cnpm i webpack webpack-cli -D 如何安装cnpm:全局运行npm i cnpm -g 注意：webpack4.X提供了约定大于配置的概念；目的是为尽量减少配置文件的体积； 默认约定了 打包的入口是src –&gt; index.js 打包的输出文件是dist –&gt; main.js 4.x新增了mode选项（为必选项），可选值为：development和production； 11.webpack-dev-server 第一步下载 npm webpack-dev-server 第二步下载 package.json 第三步 npm run dev 12.配置html-webpack-plugin插件 下载html-webpack-plugin 去config文件中配置 在项目中使用react 运行 npm i react react-dom -S安装包 react:专门用于创建组件和虚拟DOM的，同时组件的生命周期都在这个包中 react-dom：专门进行DOM操作的，最主要的应用场景，就是ReactDOM.render() 在index.html页面中，创建容器： 12&lt;!-- 容器，将来，使用`react`创建的虚拟`DOM`元素，都会被渲染到这个指定的容器中 --&gt;&lt;div id="app"&gt;&lt;/div&gt; 导入包 12import React from 'react'import ReactDOM from 'react-dom' 创建虚拟DOM元素 渲染 JSX语法什么是JSX语法？就是符合xml规范的JS语法；(语法格式，相对于HTML严谨很多) 如何启用jsx语法？ 安装babel插件 运行cnpm i babel-core babel-loader babel-plugin-transform-runtime -D 运行cnpm i babel-preset-env babel-preset-stage-0 -D 安装能够识别转换JSX语法的包babel-preset-react 运行cnpm i babel-preset-react -D 添加.babelrc配置文件 1234&#123; "presets": ["env", "stage-0", "react"], "plugins": ["transform-runtime"]&#125; 添加babel-loader配置项： 12345module: &#123; rules: [ &#123; test: /\.js|jsx$/, use: 'babel-loader', exclude: /node_modules/ &#125; ]&#125; jsx语法的本质：并不是直接把jsx渲染到页面上，而是内部先转成了createElement形式，再渲染的； 在jsx中混合写入js表达式：在jsx语法中，要把js代码写到{}中 渲染数字 渲染字符串 渲染布尔值 渲染jsx元素 渲染jsx元素数组 将普通字符串数组，转为jsx数组并渲染大页面上， 在jsx中写注释：推荐使用{/* 这是注释 */} 为jsx中的元素添加class类名：需要使用className来替代class;htmlFor替代label的for属性 在jsx创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹； 在jsx语法中，标签必须成对出现，如果是单标签，则必须是闭合的当编译引擎，在编译jsx代码的时候，如果遇到了&lt;那么就把它当做HTML代码去编译，如果遇到了{}就把花括号内部的代码当做普通js代码去编译；]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue全家桶]]></title>
    <url>%2F2018%2F11%2F10%2Fvue%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[vue全家桶vue-router vue的路由 安装： npm i vue-router 引用方式： 标签引用 模块化引用 Vue.use(router) 在根组件注册路由 render： 组件的渲染方式； 缺点：会替换div#app vue-resource 作用：vue中发送http的，但是官方已经不再维护了，建议使用axios 安装： npm i vue-resource 如何获取服务器返回的数据： then(function(res){ res.body.message }) axios 作用： 发送http请求的工具（官方建议使用的） 注意: axios`then中this指向不是当前的vue`组件对象，所以建议使用箭头函数 Vue-cli 作用：vue项目的搭建工具 可以帮助我们快速的生成一个基于webpack构建的模块化的vue项目，里面整合了常见的一些工具，比如babel和一些文件的loader还有vue的全家桶 全局安装： npm i vue-cli -g 定位到项目目录: vue init webpack &quot;项目名称&quot; vueXvue项目的状态管理（可以理解为vue的共享数据库） 作用：存储一些共享的数据，所有的组件都可以访问vuex中的共享数据，解决了组件之间传值的问题 引入：Vue.use(Vuex) var store = new Vuex.store({ }) vuex的四个核心： state状态（数据）：可以理解为组件对象中的data state中数据如何变化？ this.$store.state.** 可以通过store.state获取状态对象，store.commit触发状态变更 getter：对外提供数据，与组件中的过滤器比较像；可以认为是store的计算属性（和computed比较像），只有当它的依赖值发生了变化，才会重新计算； mutation变化：可以理解为组件对象中的methods 注意：mutations中不支持异步的操作 里面的方法专门用来操作state中的数据 更改store中的状态的唯一的方法，当store发生变化，需要提交的时候，会用到mutations 在组件中通过this.$store.commit(&#39;函数名&#39;)调用mutations中的方法 action: 类似于mutations，但不完全相同 action提交的是mutation，而不是直接变更状态； action可以包含任意异步操作 module 注意点：不要再组件中直接修改vuex中state，而是要使用commit调用mutations中的函数。去修改state的值， 好处： 避免数据紊乱，更好的追踪每个状态的变化 什么时候对组件进行拆分？ 高复用，分治的情况下对组件进行拆分 拆分组件有时是为了代码的简洁性和可阅读性 什么时候使用路由？ 适用于构建单页面应用。vue的单页面应用基于路由和组件的，路由由于设定访问路径，并将路径和组件映射起来； 传统的单页面应用是用一些超链接实现页面切换和跳转的； 在vue-router单页面应用中，则是路径之间的切换，也就是组件之间的切换 vue的一些插件： vue-resource http-server v-tap min-ui vue-clipboard2 网页端、H5操作剪切板 data、props、vueX的区别？ vueX相当于数据库，保存vue状态–就是保存vue的数据 vueX是一个全局的共享数据存储区域，只有共享的数据才能放到vueX中； data：组件内部私有的数据才可以放到组件的data中去，数据是可读可写的； props：父子组件之间传递的数据才可以放到props中，且数据是只读的；]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ref获取DOM元素和组件]]></title>
    <url>%2F2018%2F11%2F07%2Fref%E8%8E%B7%E5%8F%96DOM%E5%85%83%E7%B4%A0%E5%92%8C%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[ref获取DOM元素和组件123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;div id='app'&gt; &lt;input type="button" value="获取dom节点" @click="getElement" ref="mybtn"&gt; &lt;h3 id="myh3" ref="myh3"&gt;哈哈哈，哈哈哈&lt;/h3&gt; &lt;hr&gt; &lt;login ref="mylogin"&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;', data() &#123; return &#123; msg: 'son msg' &#125; &#125;, methods: &#123; show() &#123; console.log('调用了子组件的方法'); &#125; &#125; &#125; var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 获取DOM元素 console.log(this.$refs.myh3.innerText) // 获取子组件的信息 console.log(this.$refs.mylogin.msg) // 获取子组件的方法 this.$refs.mylogin.show() &#125; &#125;, components: &#123; login &#125; &#125;) &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命周期函数]]></title>
    <url>%2F2018%2F11%2F02%2F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[创建期间的生命周期函数：beforeCreate第一个钩子函数12345678910111213141516171819202122&lt;body&gt; &lt;div id="app"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法'); &#125; &#125;, beforeCreate() &#123; this.show() console.log(this.msg); &#125; &#125;)&lt;/script&gt; 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来就会执行它 注意：在beforeCreated生命周期函数执行的时候，data和methods中的数据还没有初始化，因此在打印的时候，是报错的，如图： created第二个生命周期函数12345678910111213141516171819202122&lt;body&gt; &lt;div id="app"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法'); &#125; &#125;, created() &#123; this.show(); console.log(this.msg); &#125; &#125;)&lt;/script&gt; 这是遇到的第二个生命周期函数,此时，data和methods都已经被初始化好了 如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作，如图： beforeMount 第三个生命周期函数123456789101112131415161718192021&lt;body&gt; &lt;div id="app"&gt; &lt;h3 id="h3"&gt; &#123;&#123; msg &#125;&#125; &lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法'); &#125; &#125;, beforeMount() &#123; console.log(document.getElementById('h3').innerText); &#125; &#125;)&lt;/script&gt; 遇到的第三个生命周期函数，表示模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中； beforeMount在执行的时候，页面中的元素，还没有被真正的替换过来，只是之前写的一些模板字符串 此函数执行的时候，模板已经在内存中编译好了，但是尚未挂载到页面中去，此时，页面还是旧的； 因此，页面上的内容与模板中的内容不一致，内存中的数据是最新的如图： mounted 第四个生命周期函数12345678910111213141516171819202122&lt;body&gt; &lt;div id="app"&gt; &lt;h3 id="h3"&gt; &#123;&#123; msg &#125;&#125; &lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法'); &#125; &#125;, mounted() &#123; console.log(document.getElementById('h3').innerText); &#125; &#125;)&lt;/script&gt; 这是遇到的第四个生命周期函数，表示，内存中的模板已经是真的挂载到了页面中，用户已经可以看到渲染好的页面了 注意：此时mounted是实例创建期间的最后一个生命周期函数，当执行完mounted就表示整个Vue实例已经初始化完毕了，此时，组件已经脱离了创建阶段,进入到运行阶段； 如果要通过某些插件操作页面中的DOM节点，最早要在mounted中进行； 如图，页面与模板中是一致的，此时页面中的数据是最新的： 运行期间的生命周期函数： 这些是组件运行期间的生命周期函数； 触发这两个生命周期函数的条件：when data changes； 执行次数会根据data数据的改变：最少执行0次，最多执行无数次； beforeUpdate123456789101112131415161718&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="戳他变变变" @click="msg='no'"&gt; &lt;h3 id="h3"&gt; &#123;&#123; msg &#125;&#125; &lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, beforeUpdate() &#123; console.log('界面上元素的内容' + document.getElementById('h3').innerText); console.log('data中的msg数据是：' + this.msg); &#125; &#125;)&lt;/script&gt; 当执行beforeUpdate的时候，页面中显示的数据还是旧的，此时data数据是最新的，页面尚未和最新数据保持同步 输出结果如图： updated123456789101112131415161718&lt;body&gt; &lt;div id="app"&gt; &lt;input type="button" value="戳他变变变" @click="msg='no'"&gt; &lt;h3 id="h3"&gt; &#123;&#123; msg &#125;&#125; &lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: 'ok' &#125;, updated() &#123; console.log('界面上元素的内容' + document.getElementById('h3').innerText); console.log('data中的msg数据是：' + this.msg); &#125; &#125;)&lt;/script&gt; updated事件执行的时候，页面和data 数据已经保持同步了，都是最新的 如图，内容保持一致的： 销毁期间的生命周期函数beforeDestroy Vue实例已经从运行阶段，进入到了销毁阶段； 当执行beforeDestroy的时候，实例上所有的data和所有的methods，以及过滤器、指令…都处于可用状态，此时，还没有真正的执行销毁的过程destroyed 当执行到destroyed函数的时候，组件已经被完全销毁了，此时，组建中所有的数据、方法、指令、过滤器…都已经不可用了]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli的基本使用]]></title>
    <url>%2F2018%2F10%2F27%2Fvue-cli%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[VUE-CLi的基本使用 Vue-cli是快速构建这个单页应用的脚手架。 使用npm安装全局vue-cli(前提你已经安装了node.js,[node -v: 可以查看node是否安装以及版本号])，在cmd中输入一下命令npm install -g vue-cli 定位到项目目录运行 vue init webpack &quot;项目名称&quot; 相关初始化信息提示：1) Runtime + Compiler: recommended for most users运行加编译2) Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere仅运行时，已经有推荐了就选择第一个了3) Install vue-router? (Y/n)是否安装vue-router，这是官方的路由，大多数情况下都使用4) Use ESLint to lint your code? (Y/n)是否使用ESLint管理代码，ESLint是个代码风格管理工 具，是用来统一代码风格的，并不会影响整体的运行5) Pick an ESLint preset (Use arrow keys)选择一个ESLint预设，编写 vue项目时的代码风格6) Standard (https://github.com/feross/standard)js的标准风格7)none (configure it yourself)自己定义风格8) Setup unit tests with Karma + Mocha? (Y/n)是否安装单元测试9) Setup e2e tests with Nightwatch(Y/n)?是否安装e2e测试10) 自己用什么就在什么的后面回车就OK了 安装完毕之后会生成项目目录 如图:]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生命周期图]]></title>
    <url>%2F2018%2F10%2F23%2F%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[生命周期函数解析图]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue传参、取值两种方式]]></title>
    <url>%2F2018%2F10%2F17%2Fvue%E4%BC%A0%E5%8F%82%E3%80%81%E5%8F%96%E5%80%BC%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[query 传值、取值 传值 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id='app'&gt; &lt;router-link to="/login?id=10&amp;name=zs"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;!-- 占位 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; // this就是指向当前创建的实例，因此不需要在这里加入this了 template: '&lt;h1&gt;登录 --&#123;&#123; $route.query.id &#125;&#125;--&#123;&#123; $route.query.name &#125;&#125;&lt;/h1&gt;', data() &#123; return &#123; msg: 'hhshsh' &#125; &#125;, created() &#123; // console.log(this.$route); // 查询参数可以直接通过 this.$route.query.id console.log(this.$route.query.id); console.log(this.$route.query.name); &#125; &#125; var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;)&lt;/script&gt; 接收参数(注意：$route)this.$route.query.id params 传值、取值12345678910111213141516171819202122232425262728293031&lt;div id='app'&gt; &lt;router-link to="/login/12/zs"&gt;登录组件&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册组件&lt;/router-link&gt; &lt;!-- 占位 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt;var login = &#123; template: '&lt;h1&gt;登录--&#123;&#123; $route.params.id &#125;&#125;--&#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;', created() &#123; // 获取$route console.log(this.$route); // params方式获取值 console.log(this.$route.params.id); console.log(this.$route.params.name); &#125;&#125;// 注册路由var router = new VueRouter(&#123; routes: [ &#123; path: '/login/:id/:name', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;)&lt;/script&gt; 接收参数this.$route.params query 是path引入; params 是name引入 query 相当于get请求，页面跳转的时候，可以在地址栏看到请求参数 params 相当于 post请求，参数不会在地址栏中显示]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>query、params</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue组件-路由]]></title>
    <url>%2F2018%2F10%2F10%2Fvue%E7%BB%84%E4%BB%B6-%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[Vue.js定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法： 1234var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录&lt;/h1&gt;&apos; &#125;); Vue.component(&apos;login&apos;, login); 直接使用 Vue.component 方法： 123Vue.component(&apos;register&apos;, &#123; template: &apos;&lt;h1&gt;注册&lt;/h1&gt;&apos; &#125;); 将模板字符串，定义到script标签种： 123&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt;&lt;/script&gt; 同时，需要使用 Vue.component 来定义组件：123Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos; &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 12345678910111213Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos;, data() &#123; return &#123; msg: &apos;大家好！&apos; &#125; &#125;, methods:&#123; login()&#123; alert(&apos;点击了登录按钮&apos;); &#125; &#125;&#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 使用components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // 定义子组件 account: &#123; // account 组件 template: &apos;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;&apos;, // 在这里使用定义的子组件 components: &#123; // 定义子组件的子组件 login: &#123; // login 组件 template: &quot;&lt;h3&gt;这是登录组件&lt;/h3&gt;&quot; &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt; 引用组件： 123&lt;div id=&quot;app&quot;&gt; &lt;account&gt;&lt;/account&gt; &lt;/div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 12345&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt; &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt; &lt;/div&gt; Vue实例定义： 123456789101112131415161718&lt;script&gt; Vue.component(&apos;myCom1&apos;, &#123; template: &apos;&lt;h3&gt;奔波霸&lt;/h3&gt;&apos; &#125;) Vue.component(&apos;myCom2&apos;, &#123; template: &apos;&lt;h3&gt;霸波奔&lt;/h3&gt;&apos; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819202122// 登录组件 const login = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component(&apos;login&apos;, login); // 注册组件 const register = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;注册组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component(&apos;register&apos;, register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; comName: &apos;login&apos; &#125;, methods: &#123;&#125; &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 12345678&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;comName=&apos;login&apos;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;comName=&apos;register&apos;&quot;&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt; 添加切换样式： 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;/style&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;这是父组件中的消息&apos; &#125;, components: &#123; son: &#123; template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;, props: [&apos;finfo&apos;] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component(&apos;son&apos;, &#123; template: &apos;#son&apos;, // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit(&apos;func&apos;, &apos;OK&apos;); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=&quot;myh1&quot;&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&apos;my-com&apos;, &#123; template: &apos;&lt;h5&gt;这是一个子组件&lt;/h5&gt;&apos;, data() &#123; return &#123; name: &apos;子组件&apos; &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; vue组件间的参数传递 父组件与子组件传值父组件传给子组件： 子组件通过props方法接受数据子组件传给父组件： $emit方法传递参数 非父子组件间的数据传递，兄弟组件传值eventBus,就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适(还有VUEX，具体看需求) vue的路由实现：hash模式 和 history模式 hash模式：在浏览器中符号“#”，#以及#后面的字符称之为hash，用 window.location.hash 读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面 history采用HTML5的新特性；且提供了两个新方法： pushState()， replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； vue路由的钩子函数首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能 beforeEach主要有3个参数to，from，next。 to：route即将进入的目标路由对象。 from：route当前导航正要离开的路由 next：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos;&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/login&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, router: router // 使用 router 属性来使用路由规则 &#125;); 在路由规则中定义参数 在规则中定义参数： 1&#123; path: &apos;/register/:id&apos;, component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: &apos;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;&apos; &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: &apos;&lt;div&gt;登录组件&lt;/div&gt;&apos; &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: &apos;&lt;div&gt;注册组件&lt;/div&gt;&apos; &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/account/login&apos; &#125;, // 使用 redirect 实现路由重定向 &#123; path: &apos;/account&apos;, component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: &apos;login&apos;, component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: &apos;register&apos;, component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;content&quot;&gt; &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component(&apos;header&apos;, &#123; template: &apos;&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;&apos; &#125;); var sidebar = Vue.component(&apos;sidebar&apos;, &#123; template: &apos;&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;&apos; &#125;); var mainbox = Vue.component(&apos;mainbox&apos;, &#123; template: &apos;&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;&apos; &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos;, fullName: &apos;jack - chen&apos; &#125;, methods: &#123;&#125;, watch: &#123; &apos;firstName&apos;: function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + &apos; - &apos; + this.lastName; &#125;, &apos;lastName&apos;: function (newVal, oldVal) &#123; this.fullName = this.firstName + &apos; - &apos; + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; &#125;); var register = Vue.extend(&#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: &quot;/login&quot;, component: login &#125;, &#123; path: &quot;/register&quot;, component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; &apos;$route&apos;: function (newVal, oldVal) &#123; if (newVal.path === &apos;/login&apos;) &#123; console.log(&apos;这是登录组件&apos;); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos; &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + &apos; - &apos; + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos; &#125;, methods: &#123; changeName() &#123; this.fullName = &apos;TOM - chen2&apos;; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + &apos; - &apos; + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(&apos; - &apos;); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed计算属性，一定要return结果，只适合写一些简单的操作，属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当做属性来使用 methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 其他小的知识点 css只在当前组件起作用在style标签中写入scoped即可 例如： $route和$router的区别$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向数据]]></title>
    <url>%2F2018%2F10%2F05%2F%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[什么是vue.js vue.js构建用户界面，只关注视图层； 前端的主要工作：主要负责MVC中的V这一层 vue中，一个核心概念，就是让用户不再操作DOM元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑 node(后端)中的MVC与前端中的MVVM之间的区别：① MVC是后端的分层开发概念② MVVM是前端图层的概念，主要关注于视图分层，也就是说，MVVM把前端的视图层分为了三部分：Model,View, ViewModel③ M -&gt; 保存的是每个页面中单独的数据④ VM -&gt; 是一个调度者，分割了M和V，每当V层想要获取后保存数据的时候，都要由VM坐中间的处理⑤ V -&gt; 每个页面中的HTML结构⑥ 数据的双向绑定是由VM提供的； v-cloak 能够解决插值表达式闪烁问题，&lt;p v-cloak&gt;++++++ ++------&lt;/p&gt; v-text 默认是没有闪烁问题的， 会覆盖元素中原本的内容，差值表达式只会替换自己的占位符，不会把整个元素的内容清空&lt;h4 v-text=&quot;msg&quot;&gt;===========&lt;/h4&gt; v-html 会覆盖元素中原本的内容，但是会把内容当做html解析放在页面中&lt;h4 v-html=&quot;msg&quot;&gt;&lt;/h4&gt;msg=&quot;&lt;h1&gt;我是一个大大的H1标题&lt;/h1&gt;&quot; v-bind 是vue中提供的用于绑定属性的指令 只能单向数据绑定，从M 自动绑定到 V&lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-bind:title=&quot;mytitle&quot;&gt;&lt;/input&gt; (v-bind:)的简写形式 只留一个冒号(:),形式 :要绑定的属性&lt;input type=&quot;button&quot; value=&quot;按钮&quot; :title=&quot;mytitle&quot;&gt;&lt;/input&gt; v-on vue中提供了 v-on事件绑定机制&lt;input type=&quot;button&quot; value=&quot;按钮&quot; v-on:click=&quot;show&quot;&gt; v-on可以简写为： @click&lt;input type=&quot;button&quot; value=&quot;按钮&quot; @click=&quot;show&quot;&gt; v-for v-for = &quot;xxx in list&quot; 注意：在使用v-for的时候，必须同时给元素指定一个key属性 v-if v-if=&quot;条件判断（会转化为bool）&quot; 成立：元素会在DOM结构中渲染 不成立：该元素不会出现在dom树中 v-show v-show=&quot;条件判断（转化为bool）&quot; 成立：元素显示 不成立：display： none v-if 与 v-show的区别： v-if: 每次回删除或创建元素 有较高的切换性能消耗 控制的元素会从页面移除/添加 v-if如果和v-for一起使用，每次循环都会判断一次 v-if成立，元素会在DOM结构中渲染 v-show： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的display：none样式 有较高的初始渲染消耗 如果元素涉及到频繁的切换，使用v-show 控制的元素会从页面显示/隐藏 事件修饰符 .stop：阻止冒泡&lt;input type=&quot;button&quot; value=&quot;戳他&quot; @click.stop=&quot;btnClick&quot;&gt; .prevent : 阻止默认事件&lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;linkClick&quot;&gt;有问题，先去百度&lt;/a&gt; .capture 捕获模式执行事件（从外向内） .self 事件在本身触发时触发回调 比如：.self只会阻止 div2 身上的事件冒泡 1234&lt;div class="outer" @click.self="div2"&gt; &lt;div class="inner" @click="div1"&gt; &lt;/div&gt;&lt;/div&gt; .once事件只触发一次 自定义修饰符vue.config.keyCodes.名称 = 按键值如： Vue.config.keyCodes.f2 = 113 使用class样式 数组&lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;]&quot;&gt;纯洁的H1表达式&lt;/h1&gt; 数组中使用三元表达式&lt;h1 :class=[&#39;red&#39;, &#39;thin&#39;, isactive ? &#39;active&#39; : &#39;&#39;]&gt;复杂的H1表达式&lt;/h1&gt; 数组中嵌套对象&lt;h1 :class=&quot;[&#39;red&#39;, &#39;thin&#39;, { &#39;active&#39;: isactive }]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象（使用v-bind绑定对象，对象的属性是类名，对象的属性可以带引号，也可以不带引号）&lt;h1 :class=&quot;{ pink:true, italic: true, active: true }&quot;&gt;这是一个善良的H1，真的，别不信&lt;/h1&gt; v-model双向数据绑定的原理及特点 原理：利用Object.defineProperty()这个方法重新定义对象获取属性值（get）和设置属性值（set）的操作实现的 特点：v-model指令只能作用在表单元素上1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;!-- vue双向数据绑定的原理 --&gt; &lt;input type="text" id="myInput"&gt; &lt;span id="mySpan" &gt;&lt;/span&gt; &lt;/body&gt; &lt;script&gt; var data = &#123; msg:'哈哈哈哈哈' &#125; myInput.value = data.msg; mySpan.innerText = data.msg; // VUE中双向数据绑定的原理 就是 Object.defineProperty // 参数1 对象 // 参数2 对象中需要定义的属性 // 参数3 该属性的一些配置 Object.defineProperty(data,'msg',&#123; get:function()&#123; return myInput.value; &#125;, set:function(newValue)&#123; myInput.value = newValue; mySpan.innerText = newValue; &#125; &#125;) myInput.onkeyup = function()&#123; data.msg = this.value; console.log(data.msg) &#125; // var str = data.msg // 读取msg的值 ----&gt; get // data.msg = xxxx // 设置msg的值 -----&gt; set &lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6-Promise]]></title>
    <url>%2F2018%2F09%2F25%2FES6-Promise%2F</url>
    <content type="text"><![CDATA[Promise概念: Promise 是一个构造函数，既然是构造函数，那么我们就可以new Promise()得到一个 Promise 的实例； 在 Promise 上，有两个函数，分别叫做 resolve（成功之后的回调函数）和reject（失败之后的回调函数） 在 Promise 构造函数的 Prototype 属性上，有一个 .then() 方法，也就是说，只要是 Promise构造函数创建的实例，都可以访问到 .then()方法； Promise 表示一个异步操作；每当我们new一个 Promise 实例，这个实例，就表示一个具体的异步操作； 既然 Promise 创建的实例，是一个异步操作，那么，这个异步操作的结果，只能有两种转态： 5.1 转态1：异步执行成功了，需要在内部调用，成功的回调函数 resolve 把结果返回给调用者； 5.2 状态2：异步执行失败了，需要在内部调用，失败的回调函数 reject 把结果返回给调用者 5.3 由于Promise 的实例，是一个异步操作，所以内部拿到操作结果后，无法使用return 把操作的结果返回给调用者 我可以在 new 出来的 Promise 实例上，调用.then() 方法，【预先】为这个 Promise 异步操作，指定 成功(resolve) 和 失败(reject) 回调函数 注意： 这里 new 出来的 promise， 只是代表 【形式上】的一个异步操作； 什么是形式上的异步操作：就是说，我们只知道它是一个异步操作，但是做什么具体的异步事情，目前还不清楚 var promise = new Promise() 这是一个具体的异步操作，其中，使用 function 指定一个具体的异步操作 var promise = new Promise(function() { ​ &#39;这个 function 内部写的就是具体的异步操作&#39; })1234567891011const fs = require('fs')/** * 每当new一个 Promise 实例的时候，就会立即执行这个异步操作中的代码 * 也就是说，new的时候，除了能够得到一个 Promise 实例之外， 还会立即代用 我们为 Promise 构造函数传递的那个function，执行这个function 中的异步操作代码：*/var promise = new Promise(function() &#123; fs.readFile('./files/2.txt', 'utf-8', (err, dataStr) =&gt; &#123; if(err) throw err console.log(dataStr) &#125;)&#125;) Promise 的本质 Promise 的本质：就是单纯的为了解决回调地狱的问题，并不能帮我们减少代码量; 使用ES6中的 Promise，来解决回调地域问题 new Promise的时候，会立即执行它的参数 then()方法默认返回的就是一个promise对象 在then中做异步操作，如果想维持这个then的函数链，那么必须要return new Promise then 代表执行的顺序Promise 捕获异常的两种方式： 如果前面的 Promise 执行失败，我们不想让后续的Promise操作被终止； 当 我们有这样的需求： 哪怕前面的 Promise 执行失败了，但是，不要影响后续 promise 的正常执行，此时，我们可以单独为 每个 promise通过 .then()指定一下失败的回调；123456789101112131415161718192021222324252627282930313233const fs = require('fs')function getFileByPath(fpath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fpath, 'utf-8', (err, dataStr) =&gt; &#123; if (err) return reject(err) resolve(dataStr) &#125;) &#125;)&#125;getFileByPath('./files/11.txt') .then(function (data) &#123; console.log(data) // 读取文件2 return getFileByPath('./file/2.txt') &#125;, function (err) &#123; console.log('这是失败的结果:' + err.message); // return 一个新的 Promise return getFileByPath('./files2.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;, function(err)&#123; console.log('这是失败的结果:' + err.message); return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;)console.log('ok ok ok') 有时候，我们有这样的需求，和上面的需求刚好相反：如果 后续的Promise 执行，依赖于 前面 Promise执行的结果，如果前面的失败了，则后面的就没有继续执行下去的意义了，此时，我们想要实现，一旦有报错，则立即终止所 Promise的执行； catch 的作用： 如果前面有任何的 Promise 执行失败，则立即终止所有 promise 的执行，并 马上进入 catch 去处理 Promise中 抛出的异常123456789101112131415161718192021222324252627282930const fs = require('fs)function getFileByPath(fpath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fpath, 'utf-8', (err, dataStr) =&gt; &#123; if (err) return reject(err) resolve(dataStr) &#125;) &#125;)&#125;getFileByPath('./files/1.txt') .then(function (data) &#123; console.log(data) // 读取文件2 return getFileByPath('./files/22.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;) // catch处理 Promise异常 .catch(function (err) &#123; console.log('这是自己的处理方式：' + err.message) &#125;)console.log('ok ok ok') 在读取文件的案例中为什么封装Promise函数？Promise表示一个异步操作，每当我们new Promise的时候 会立刻执行它的参数，而封装函数，就会阻止Promise的立即执行，在调用函数的时候，才会执行，Promise执行变得可控。。 jquery中的 Promise 初始化配置文件，安装jQuery npm i -y npm i jquery 随便写了一个data.json的文件(注意：json文件里面不能有注释，且必须双引号(“”)包裹)1234&#123; "name": "你的笑像一条恶狗", "gender":"撞乱了我心弦"&#125; 12345678910111213141516171819&lt;body&gt; &lt;input type="button" value="获取数据" id="btn"&gt; &lt;script src="./node_modules/jquery/dist/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $('#btn').on('click', function () &#123; $.ajax(&#123; type: 'get', //get或post url: './files/data.json', //请求的地址 // data: &#123;&#125;, //请求的参数，a=1&amp;b=2或&#123;a:1,b:2&#125; dataType: 'json', //text,json,xml success: function (data) &#123; //成功的回调函数 console.log(data); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6常用语法]]></title>
    <url>%2F2018%2F09%2F17%2FES6%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ECMAScript 6常用语法 var定义的变量 存在变量提升问题，降低 js 代码的可阅读性 没有块级作用域，容易造成变量污染 可以跨块访问，不能跨函数访问 let 主要特性： 不存在变量提升问题，只有定义之后才能使用此变量 只能在块作用域访问，不能跨块访问，也不能跨函数访问 有 { } 作用域 const 主要特性： 不存在变量提升问题，只有定义之后才能使用此变量 const 定义的常量，无法被重新赋值 当定义常量的时候，必须定义且初始化（即必须赋值），否则报语法错误 const 定义的常量，也有 块级作用域 变量的结构赋值 定义：所谓的解构赋值，就是把 某个对象中的属性，当作变量，给解放出来，这样，今后就能够当作变量直接使用了； 可以使用 :为解构出来的变量重命名123// 变量的解构赋值const &#123; name : name123, age, gender &#125; = personconsole.log(name123) 箭头函数(常用) 语法： 定义普通的function函数 123function show() &#123; console.log('这是普通function 函数定义show的方法')&#125; 把方法定义为箭头函数（最完整的写法）（形参列表） =&gt; { 函数体代码 } 箭头函数本质上就是一个匿名函数 箭头函数的特性： 箭头函数内部的this，永远和箭头函数外部的this保持一致； 变体： 123var add = (x, y) =&gt; &#123; return x + y&#125; 变体1：如果箭头函数，左侧的形参列表中，只有一个参数，则，左侧小括号可以省略； 123var add = x =&gt; &#123; return x + y&#125; 变体2：如果右侧函数体中，只有一行代码，则，右侧的 { } 可以省略, 同时return也要去掉； 1var add = (x, y) =&gt; x + y 变体3：如果箭头函数左侧 只有一个 形参，而且右侧只有一行代码，则 两边的 () 和 {} 都可以省略 1var add = x =&gt; x + y 注意: 另外，如果省略了右侧的函数体{},那么，默认会把右侧函数体重代码的执行结果当做箭头函数的调用结果return出去；]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础]]></title>
    <url>%2F2018%2F09%2F15%2Fnode%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. Javascript 的单线程和异步 Javascript 的解析和执行一直是单线程的，但是宿主环境（浏览器或node）是多线程的； 异步任务是由宿主环境开启子线程完成，并通过事件驱动、回调函数、队列，把完成的任务, 交给主线程执行; Javascript解析引擎，一直在做一个工作，就是从任务队列里提取任务，放到主线程里执行。 2. Node中的API为什么几乎都是异步操作 什么样的操作需要使用异步处理：要把 耗时的操作，放到异步中去执行； 异步执行任务的好处：能够提高 耗时的任务它的执行效率，提高 JS 解析引擎的工作效率； 3. 模块化 模块化就是一种约定，一定规范； 场景模拟：小强，小黄，小刚 共同基于 Node.js 开发项目！ 为什么要有模块化：为了解决文件之间的依赖关系； 注意：模块化是一种开发思想；具体开发中需要定制符合实际需求的模块化规范！ 大家可以把模块化规范，认为是一种明文的约定，大家都按照相同的约定写代码，减少了不必要的沟通成本，极大方便了各个模块之间的调用，方便别人，同时也方便自己； 4. CommonJS 规范 作用：是一套 Javascript 的模块化规范，规定了 模块的特性 和 各模块之间如何相互依赖； 用途：Node.js 中使用了 CommonJS 规范； 特点：同步加载模块；不适合在浏览器端使用； CommonJS规范都定义了哪些内容：wiki 对于 Modules 的描述 5. 模块作用域 和 全局作用域 在Node.js中有两个作用域，分别是 全局作用域 和 模块作用域； 全局作用域使用 global 来访问，类似于浏览器中的window； 每个 Javascript 文件，都是一个单独模块，每个模块都有自己独立的作用域，因此：模块中的成员，默认无法被其它模块访问。 5.1 使用 global 全局作用域在模块之间共享成员 如果在某个模块内部，想为 全局的 global 作用域挂载一些属性，需要显示的调用global.***来挂载； 注意：在开发中，一般情况下，不推荐使用global全局作用域来共享成员，会存在全局变量污染问题； 5.2 模块作用域 module（模块标识） module 属性是 Common JS 规范中定义的，它是一个对象，表示当前这个具体的 js 模块； require（引用模块） 每一个实现了 CommonJS 规范的模块，必须定义一个 require() 函数，使用这个 require 函数，就能够 很方便的导入其它 模块中的成员，供自己使用； exports（暴露模块成员） 每一个模块中，如果想要把自己的一些私有成员，暴露给别人使用，那么，必须实现一个 exports 对象，通过exports对象，可以方便的把模块内私有的成员，暴露给外界使用； 5.3 module.exports 和 exports 的关系 module.exports 和 exports 默认引用了同一个空对象； module.exports 和 exports 作用一致，都可以向外暴露成员； 一个模块作用域中，向外暴露私有成员时，永远以 module.exports 为准； 6.浏览器端的 AMD 和 CMD 模块化规范 注意：浏览器端不能使用 CommonJS规范；因为 CommonJS 下，模块是同步加载的； AMD/CMD可以理解为是commonjs在浏览器端的解决方案，AMD/CMD下，模块都是异步加载的； AMD模块化规范代表：RequireJS 主要特性1：对于依赖的模块，AMD 是提前执行； 主要特性2：推崇依赖前置； CMD模块化规范代表：SeaJS 主要特性1：对于依赖的模块，CMD 是延迟执行；CMD 推崇 as lazy as possible. 主要特性2：推崇依赖就近； ES6的模块化（大趋势）：es6是在语言标准层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案； 7. Node.js 中 模块 和 包 的概念 回顾：Node.js 由三部分组成：ECMAScript 核心 + 全局成员 + 模块成员 7.1 模块成员的分类 模块成员，根据一些区别，又可以分为三大类： 核心模块、第三方模块、用户自定义模块 7.1.1 核心模块 什么是核心模块： 随着Node.js的安装包，一同安装到本地的模块，叫做核心模块； 例如：fs，path等模块，都是由Node.js官方提供的核心模块； 只要大家在计算机中，安装了Node这个应用程序，那么，我们的计算机中就已经安装了所有的 核心模块； 如何使用核心模块：require(&#39;核心模块标识符&#39;) 7.2.2 第三方模块 什么是第三方模块： 一些非官方提供的模块，叫做第三方模块； 注意，第三方模块，并不在我们的计算机上； 如果大家需要使用某些第三方模块，必须去一个叫做 NPM 的网站上搜索并下载才能使用； 如何使用第三方模块： 先从 npm 官网上下载指定的第三方模块 使用 require(&#39;第三方模块的名称标识符&#39;)来导入这个模块 根据 第三方模块的 官方文档，尝试使用 7.2.3 用户自定义模块 什么是用户模块： 程序员在自己项目中写的 Javascript 文件，就叫做 用户自定义模块； 如何使用用户模块：require(&#39;路径标识符&#39;) 7.2 包的定义和使用7.2.1 什么是包 英文名叫做 Packages，包是在模块基础上更深一步的抽象； 包的目的：方便分发和推广基于 CommonJS 规范实现的 应用程序 或 类库； 包可以看作是 模块、代码 和 其它资源 组合起来形成的 独立作用域； 7.2.2 规范的包结构 包都要以一个单独的目录而存在； package.json 必须在包的顶层目录下； package.json 文件必须符合 JSON 格式，并且必须包含如下三个属性：name, version, main name: 包的名字 version: 包的版本号 main: 表示包的入口文件 二进制文件应该在bin目录下; javaScript代码应该在lib目录下; 文档应该在doc目录下; 单元测试应该在test目录下; Node.js对包要求并没有那么严格，只要顶层目录下有package.json，并符合基本规范即可; 7.2.3 包描述文件 package.json【了解】1234567891011name：包的名称，必须是唯一description：包的简要说明version：符合语义化版本识别规范的版本字符串keywords：关键字数据，通常用于搜索maintainers：维护者数组，每个元素要包含name、email、web可选字段contributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素bugs：提交bug的地址，可以是网址或者电子邮件地址licenses：许可证数组，每个元素要包含type和url字段repositories：仓库托管地址数组，每个元素要包含type、url和path字段dependencies：包的依赖，一个关联数组，由包名称和版本号组成。devDependencies：开发依赖项，表示一个包在开发期间用到的依赖项 8. npm8.1 npm 的含义 NPM 是一个 第三方模块的托管网站，指的就是https://www.npmjs.com/； NPM 是Node的包管理工具（全名叫做 Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具； 8.2 安装和卸载全局包（i5ting_toc） 什么是全局的包：安装到计算机全局环境中的包，叫做全局包；安装的全局包可以在当前电脑的任何目录下，直接通过命令行来访问； 如何安装全局包：运行 npm install 包名 -g 即可；其中 -g 参数，表示 把包安装到全局目录中的意思； 全局包的安装目录：C:\Users\用户目录\AppData\Roaming\npm 什么样的包适合安装到全局：工具性质的包，适合安装到全局； 如何卸载全局包：要卸载某个全局的包，直接运行npm uninstall 包名 -g即可；其中 uninstall 表示卸载的意思； 8.3 安装和卸载本地包 什么是本地的包：跟着项目安装的包，叫做本地包；本地包都会被安装到 node_modules 目录下； 注意：如果拿到一个空项目，必须在当前项目根目录中，先运行 npm init或者npm init -y 命令，初始化一个package.json的配置文件，否则包无法安装到本地项目中； 如何安装本地包：运行npm i 包名 --save 即可安装本地包；都安装到了当前项目的 node_modules目录下； 如果大家用的是npm 5.x的版本，可以不指定--save命令，如果用的是 npm 3.x 的版本，则需要手动指定 --save； package-lock.json文件中记录了曾经装过的包的下载地址，方便下次直接下载包，能够加快装包的速度，提升装包的体验； 如何卸载本地包：使用 npm uninstall/remove 包名 -S/-D即可卸载指定的本地包； 8.4 其它常用命令 --save 的缩写是 -S --save-dev的缩写是 -D install 的缩写是 i 注意：dependencies 节点，表示项目上线部署时候需要的依赖项；devDependencies节点，表示项目在开发阶段需要的依赖项，但是当项目要部署上线了，devDependencies节点中的包，就不再需要了！ 注意：当使用 npm i快速装包的时候，npm会检查package.json文件中，所有的依赖项，然后都为我们安装到项目中 --production 表示只安装 dependencies 节点下，记录的包，不安装devDependencies节点下的包；当项目要上线了，才会使用--production命令 8.5 解决 npm 下载慢问题 默认，NPM在下载包的时候，连接的是国外的服务器，所以，有时候如果网速不是特别好，可能下载不下来包；此时，大家可以全局安装一个的工具，叫做 cnpm 如何安装cnpm：运行 npm i cnpm -g 即可； 如何使用cnpm：在装包的时候，只需要把 npm 替换成 cnpm 即可，例如： 使用 npm 安装 jquery：运行 npm i jquery -S 使用 cnpm 安装 jquery： 运行 cnpm i jquery -S 9. 使用 Node 构建 web 应用 PHP是后端的网站开发语言，PHP 开发出来的网站，可以通过 Apache 服务器托管运行起来； 疑问：Node中，可以使用 Javascript 编写后端网站，那么，有没有类似于 Apache 这样的服务器软件，来提供对应的网站服务呢？ 9.1 B/S 交互模型 什么是B/S：特指基于 浏览器（Browser） 和 服务器（Server） 这种交互形式； 什么是服务器：在网络节点中，专门对外提供资源服务的一台电脑； 什么是客户端：在网络节点中，专门用来消费服务的一台电脑； HTTP 协议的通信模型：请求 - 处理 - 响应的过程； 请求：由客户端发起请求； 处理：由服务器端处理请求； 响应：服务器端把处理的结果，通过网络发送给客户端； 什么是静态资源：服务器端只需要读取并直接发送给客户端、不需要进一步处理的资源，叫做静态资源； 什么是动态资源：服务器端没有现成的资源，需要服务器端动态生成的资源，叫做动态资源； 9.2 实现一个类似于Apache的 静态资源服务器 使用http核心模块，创建最基本的web服务器 创建最基本的web服务器 创建服务器：使用 const server = http.createServer() 创建服务器； 绑定监听事件：通过 server.on(&#39;request&#39;, function(req, res) { 请求的处理函数 }) 绑定事件 并 指定 处理函数； 启动服务器：通过 server.listen(端口, IP地址, 启动成功的回调函数) 来启动服务器； 防止响应内容中文乱码问题 通过 设置响应报文头的 Content-Type，来指定响应内容的编码类型，从而防止乱码： 123res.writeHeader(200, &#123; 'Content-Type': 'text/plain; charset=utf-8'&#125;) 根据不同的URL返回不同的文本内容 使用 req.url 获取客户端请求的URL地址 根据不同的URL返回不同的HTML页面 主要思路：使用 fs 模块 读取URL对应的HTML页面内容，并使用 res.end() 响应给客户端即可； 处理并返回css样式表 处理并返回Javascript文件 优化 实现类似于Apache的静态资源服务器 12345678910111213141516171819202122232425// 1. 导入 http 核心模块const http = require('http')// 2. 调用 http.createServer 方法，创建一个web 服务器对象// 通过 第二步 创建的 server 服务器，并不能监听任何 客户端的请求；同时 它也没有被启动const server = http.createServer()// 3. 为 server 服务器 绑定 监听函数，通过 on 方法，绑定 request 事件，来监听 客户端的请求server.on('request', function (req, res) &#123; // 可以通过 request 事件，来监听并处理客户端的请求； // req 表示 客户端 相关的参数 // res 表示 和 服务器相关的参数 和 方法 // res.end('hello world.') res.writeHeader(200, &#123; 'Content-Type': 'text/plain; charset=utf-8' &#125;) res.end('你好，世界。')&#125;)// 4. server.listen 来启动服务器server.listen(3000, '127.0.0.1', function () &#123; console.log('server running at http://127.0.0.1:3000')&#125;) 相关文章 js模块化编程之彻底弄懂CommonJS和AMD/CMD！ 把模块化彻底搞个明白（ES6模块/CommonJS/AMD/CMD） wiki 对于 Modules的描述 wiki 对于 Packages的描述 nodejs模块与包 js的单线程和异步]]></content>
      <categories>
        <category>前端</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nrm使用过程]]></title>
    <url>%2F2018%2F09%2F04%2Fnrm%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[nrm 提供了一些常用的NPM包镜像地址，快速的切换安装包时候的服务器地址 以前的包都是只存在于国外，由于网络原因，经常访问不到，而nrm是在国内创建的一个和官网完全一样的NPM服务器，只是，数据还是从别人那里拿过来，除此之外，使用方式完全一样； 下图为使用的演示过程： 注意：nrm只是提供了一些常用的下载包的URL地址，并能够让我们在这几个地址之间，很方便的进行切换，但是，每次安装包的时候，使用的装包工具还是npm]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>nrm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密]]></title>
    <url>%2F2018%2F09%2F01%2F%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[MD5的特性 MD5 是一种加密算法，在调用这个算法的时候，提供一个密码的明文， 调用的结果，得到一个 32 位长度的密文； MD5 算法的特性：相同的字符串，如果多次调用 md5 算法，得到的结果，完全一样； MD5 算法，无法被逆向解密； 但是，基于 md5 算法的第二个特性，我们可以进行碰撞暴力破解；（MD5 存在被暴力破解的安全性问题） 为了解决 简单的明文密码，被 md5 加密后，通过 暴力破解的安全性问题， 然后就出现了加盐的MD5加密； 目前，md5的暴力破解，又升级了，升级到了 彩虹表； 由于彩虹表出现，我们推荐大家，在存储网站密码的时候，使用 bcrypt 加密算法，得到加密之后的密文进行存储； bcrypt 加密算法 在调用加密算法的时候，需要手动提供一个 幂次; 调用加密算法，得到的加密结果格式：$版本号$循环的幂次$22位的随机盐 31位的密文 加密的随机盐和加密的幂次，和加密算法的版本号已经被存储到了真正的密文中； 项目中使用 bcrypt 的步骤 运行npm i node-pre-gyp 在项目根目录中，打开终端，运行npm install bcrypt -S导入bcrypt 导入bcrypt 12// 导入加密的模块 const bcrypt = require('bcrypt') 定义幂次 12 // 定义一个幂次const saltRounds = 10 // 2^10 调用bcrypt.hash()加密： 1234// 加密的方法bcrypt.hash('123', saltRounds, (err, pwdCryped) =&gt; &#123;console.log(pwdCryped)&#125;) 调用bcrypt.compare()对比密码是否正确 12345678910111213// 对比 密码的方法bcrypt.compare('123', '$2b$10$i1ufUKnC9fXTsF9oqqvLMeDnpNfYIvhyqKRG03adiebNFPkjW3HPW', function(err, res) &#123; console.log(res) // 内部对比的过程： // 1. 先获取 输入的明文 // 2. 获取输入的密文 // 2.1 从密文中，解析出来 bcrypt 算法的 版本号 // 2.2 从密文中，解析出来 幂次 // 2.3 从密文中，解析出来前 22 位 这个随机盐 // 3. compare 方法内部，调用 类似于 hash 方法 把 明文，幂次，随机盐 // 都传递进去 最终得到正向加密后的密文 // 4. 根据最新得到的密文，和 compare 提供的密文进行对比，如果相等，则 返回 true ，否则返回 false;&#125;)]]></content>
      <categories>
        <category>前端</category>
        <category>加密</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex布局]]></title>
    <url>%2F2018%2F08%2F22%2Fflex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[伸缩布局布局的传统解决方案，基于盒装模型，依赖于display属性 + position属性 + float属性。它对于那些特殊布局非常不方便。CSS3在布局页面方面做了非常强大的改进，使的我们对块级元素的布局排列变得十分灵活，强大的伸缩性，在响应式中可以发挥极大的作用。 重要属性 display: flex; 如果一个容器设置了这个属性，那么这个盒子里面的所有直接子元素都会自动变成伸缩项（flex item） justify-content:定义了项目在主轴上的对齐方式 语法：justify-content: flex-start | flex-end | center | space-between | space-around flex-start(默认值): 左对齐 flex-end: 右对齐 center: 居中 space-between: 两端对齐，项目之间的间隔相等 space-around: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍； flex-flow: 是 flex-direction 属性和 flex-wrap 属性的简写；默认值是row nowrap; flex-flow:flex-direction | flex-wrap flex-direction：决定主轴的方向（项目排列方向：） flex-direction: row | row-reverse | column | column-reserve； row(默认值)：主轴为水平方向，起点在左端； row-reverse：主轴为水平方向，起点在右端； column：主轴为垂直方向，起点在上沿； column：主轴为垂直方向，起点在下沿； flex-wrap：控制flex容器是单行或者多行 flex-wrap：nowrap | wrap | wrap-reverse； nowrap(默认)：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex属性：是flex-grow，flex-shrink 和 flex-basis的简写，默认值： 0 1 auto，后两个属性可选; flex-grow：定义项目的放大比例，默认：0，即如果存在剩余空间，也不放大 如果所有项目的flex-grow属性都是1，则将它们等分剩余空间；如果一个项目的flex-grow属性为2，其他项目为1，前者占据的剩余空间将比其他项目多一倍； flex-shrink：定义了项目缩小的比例，默认为1，即，如果空间不足，该项目将缩小； 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小；如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不会缩小； 负值对该属性无效 flex-basis：属性值被设为auto的伸缩项，会根据主轴自动伸缩以占用所有剩余空间 它可以设为跟width跟height属性一样的值(比如：350px)，则项目将占据固定的空间； (^○^) 还有很多。。。。(^○^) 在百度上。。。。。 (^○^)..一些案例： 宽高自适应 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .layout &#123; width: 500px; height: 600px; background-color: #CCCCCC; margin: 10px auto; /*设置父容器为伸缩盒子*/ display: flex; /*默认的主轴是row,这里需要以列的方式进行排列*/ flex-direction: column; &#125; header &#123; width: 100%; height: 60px; background-color: red; &#125; main &#123; width: 100%; background-color: green; /*让当前伸缩项占据父容器的剩余空间*/ flex: 1; /*让main成为伸缩盒子*/ display: flex; &#125; main&gt;article &#123; height: 100%; flex: 1; background-color: pink; &#125; main&gt;aside &#123; height: 100%; flex: 3; background-color: darkblue; &#125; footer &#123; width: 100%; height: 80px; background-color: purple; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;header&gt;&lt;/header&gt; &lt;main&gt; &lt;article&gt;&lt;/article&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; 伸缩布局常用属性：align-items 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .box &#123; width: 900px; height: 600px; border: 1px solid red; margin: 0 auto; /*设置父容器为盒子：会使每一个子元素自动变成伸缩项 当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩*/ display: flex; /*设置子元素的主轴方向上的排列方式*/ justify-content: space-around; /*align-items:设置子元素(伸缩项)在侧轴方向上的对齐方式 center:设置在侧轴方向上居中对齐 flex-start:设置在侧轴方向上顶对齐 flex:end:设置在侧轴方向上底对齐 stretch:拉伸：让子元素在侧轴方向上进行拉伸，填充满整个侧轴方向&gt;&gt; 默认值 baseline:文本基线*/ align-items: center; &#125; .first &#123; width: 200px; height: 200px; background-color: red; align-self: flex-start; &#125; .second &#123; width: 200px; height: 200px; background-color: green; /*设置单个元素在侧轴方向上的对齐方式*/ align-self: flex-end; &#125; .third &#123; width: 200px; height: 200px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="first"&gt;bb&lt;/div&gt; &lt;div class="second" style="font-size: 100px"&gt;gg&lt;/div&gt; &lt;div class="third"&gt;klkaslg&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 伸缩菜单 123456789101112131415161718192021222324252627282930313233343536373839404142434445 &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; div &#123; width: 500px; height: 400px; border: 1px solid #ccc; margin: 100px auto; &#125; div&gt;ul &#123; list-style: none; width: 100%; /*将父容器设置了伸缩盒子，子元素默认成为伸缩项 float margin*/ display: flex; &#125; div&gt;ul&gt;li &#123; /*宽度 1.我们并不知道li的具体的数量 2.也不直接设置%*/ height: 36px; line-height: 36px; text-align: center; background-color: #9fff9d; border-right: 1px solid #ccc; flex: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;商品分类&lt;/li&gt; &lt;li&gt;我的订单&lt;/li&gt; &lt;li&gt;最新商品&lt;/li&gt; &lt;li&gt;联系我们&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt; flex 属性 12345678910111213141516171819202122232425262728293031323334353637 &lt;style&gt; *&#123; padding: 0; margin: 0; &#125; .box&#123; width: 800px; height: 500px; background-color: #ccc; margin:0 auto; /*设置父容器的为伸缩盒子*/ display: flex; /*设置子元素在主轴方向上的排列方式*/ /*justify-content: flex-start;*/ &#125; .left&#123; /*flex是用来设置当前伸缩子项占据剩余空间的比例值*/ flex: 2 2 auto; width:1000px; height: 500px; background-color: red; &#125; .right&#123; /* flex: 4; */ flex: 2 5 auto; width:2800px; height: 500px; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>Flex布局</category>
      </categories>
      <tags>
        <tag>Flex布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组去重]]></title>
    <url>%2F2018%2F08%2F21%2F%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%2F</url>
    <content type="text"><![CDATA[ES6数去重 方法一： 利用Array.from 和 Set 成员唯一性 12345678910111213&lt;script&gt; // ES6为数组去重：ES6中新增了Set和Array.from // set是一种新的数据结构，可以接收一个数组或者类数组对象，自动去重其中的重复项目 var arr = [1, 2, 3, 4, 5, 4, 3, null, null, NaN]; console.log(new Set(arr)); // 但是此时返回的是对象的形式，需要的是一个数组 // Array.from可以把类数组对象、可迭代对象转化为数组 var newArr = Array.from(new Set(arr)) console.log(newArr);&lt;/script&gt; 利用展开运算符和 Set成员的唯一性 1234567&lt;script&gt; let arr = [1, 2, 3, 2, 4, 3] function only(arr) &#123; return [...new Set(arr)]; &#125; console.log(only(arr));&lt;/script&gt; ES5数组去重1234567891011121314&lt;script&gt; // ES5实现去重 var arr = [1, '1', 1, 2, 2, 1] var tmpObj = &#123;&#125;; var result = []; arr.forEach(function (a) &#123; var key = (typeof a) + a; if (!tmpObj[key]) &#123; tmpObj[key] = true; result.push(a); &#125; &#125;) console.log(result);&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装ajax函数]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%B0%81%E8%A3%85ajax%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[封装ajax函数的目的 了解ajax函数的原理 理解success函数参数的含义 掌握jq中$.ajax各属性的含义 测试数据如下（随意手写的data.json文件）： 123&#123; "name": "这鬼天气强迫我穿上了秋裤"&#125; 因为有时候我们的接口数据的获取需要传入参数，比如?id=1指定到底获取哪条数据，我们这里假设数据需要传入参数a=1&amp;b=2 我们先用get方式实现 12345678910&lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open('get', './data.json?a=1&amp;b=2'); xhr.send(null); xhr.onreadystatechange = function () &#123; if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; console.log(JSON.parse(xhr.responseText)) &#125; &#125;&lt;/script&gt; 接下来用post实现 1234567891011&lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open('post', './data.json') xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('a=1&amp;b=2'); xhr.onreadystatechange = function() &#123; if(xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; console.log(JSON.parse(xhr.responseText)); &#125; &#125;&lt;/script&gt; 封装 1234567891011121314151617181920212223&lt;script&gt; function ajax(type, url, data, dataType)&#123; var xhr = new XMLHttpRequest(); if(type == 'get') &#123; xhr.open('get', './data.json?' + data); xhr.send(null); &#125; else &#123; xhr.open('post', url) xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(data); &#125; xhr.onreadystatechange = function() &#123; if(xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; if(dataType == 'json') &#123; console.log(JSON.parse(xhr.responseText)); &#125; else &#123; console.log(xhr.responseText); &#125; &#125; &#125; &#125; ajax('get', './data.json', 'a=1&amp;b=2', 'json');&lt;/script&gt; 进一步改造上面的代码 1234567891011121314151617181920212223242526&lt;script&gt; function ajax(type, url, data, dataType) &#123; var xhr = new XMLHttpRequest(); if (type == 'get') &#123; xhr.open('get', './data.json? + data'); xhr.send(null); &#125; else &#123; xhr.open('post', url) xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencode') xhr.send(data); &#125; xhr.onreadystatechange = function() &#123; if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; var success = function(data) &#123; console.log(data); &#125; if (dataType == 'json') &#123; success(JSON.parse(xhr.responseText)) &#125; else &#123; success(xhr.responseText) &#125; &#125; &#125; &#125; ajax('get', './data.json', 'a=1&amp;b=2', 'json');&lt;/script&gt; 提取success函数作为参数 1234567891011121314151617181920212223&lt;script&gt; function ajax(type, url, data, dataType, success) &#123; var xhr = new XMLHttpRequest(); if(type == 'get') &#123; xhr.open('get', './data.json?' + data); xhr.send(null) &#125; else &#123; xhr.open('post', url); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(data); &#125; xhr.onreadystatechange = function() &#123; if(xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; success(JSON.parse(xhr.responseText)) &#125; else &#123; success(xhr.responseText) &#125; &#125; &#125; ajax('get', './data.json', 'a=1&amp;b=2', 'json', function(data) &#123; console.log(data); &#125;);&lt;/script&gt; 这样的代码在传参的时候很麻烦，考虑用对象的形式来传递 12345678910111213141516171819202122232425262728&lt;script&gt; function ajax(type, url, data, dataType, success) &#123; if (typeof data == 'object') &#123; var str = ""; for (var i in data) &#123; str = i + '=' + data[i] + '&amp;'; &#125; str = str.slice(0, str.length - 1) data = str; &#125; var xhr = new XMLHttpRequest(); if(type == 'get') &#123; xhr.open('get', './data.json?' + data); xhr.send(null) &#125; else &#123; xhr.open('post', url); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(data); &#125; xhr.onreadystatechange = function() &#123; if(xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; success(JSON.parse(xhr.responseText)) &#125; else &#123; success(xhr.responseText) &#125; &#125; &#125;&lt;/script&gt; 把参数换成对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script&gt; function ajax(obj) &#123; type = obj.type; url = obj.url; data = obj.data; dataType = obj.dataType; success = obj.success; if (typeof data == 'object') &#123; var str = ""; for (var i in data) &#123; str = i + '=' + data[i] + '&amp;'; &#125; str = str.slice(0, str.length-1) data = str; &#125; var xhr = new XMLHttpRequest(); if (type == 'get') &#123; xhr.open('get', './data.json?' + data); xhr.send(null); &#125; else &#123; xhr.open('post', url); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(data); &#125; xhr.onreadystatechange = function () &#123; if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; if(dataType == 'json') &#123; success(JSON.parse(xhr.responseText)) &#125; else &#123; success(xhr.responseText) &#125; &#125; &#125; &#125; ajax(&#123; type: 'get', url: './data.json', data: &#123; a: 1, b: 2 &#125;, dataType: 'json', success: function (data) &#123; console.log(data); &#125; &#125;)&lt;/script&gt; 全局变量容易造成变量污染，把它挂在一个对象上 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt; var itcast = &#123; ajax: function (obj) &#123; type = obj.type; url = obj.url; data = obj.data; dataType = obj.dataType; success = obj.success; if (typeof data == 'object') &#123; var str = ""; for (var i in data) &#123; str = i + '=' + data[i] + '&amp;'; &#125; str = str.slice(0, str.length - 1) data = str; &#125; var xhr = new XMLHttpRequest(); if (type == 'get') &#123; xhr.open('get', './data.json?' + data); xhr.send(null); &#125; else &#123; xhr.open('post', url); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(data); &#125; xhr.onreadystatechange = function () &#123; if (xhr.status == 200 &amp;&amp; xhr.readyState == 4) &#123; if (dataType == 'json') &#123; success(JSON.parse(xhr.responseText)) &#125; else &#123; success(xhr.responseText) &#125; &#125; &#125; &#125; &#125; itcast.ajax(&#123; type: 'get', url: './data.json', data: &#123; a: 1, b: 2 &#125;, dataType: 'json', success: function (data) &#123; console.log(data); &#125; &#125;)&lt;/script&gt; 如上封装，需要了解： success 我们这里写的是data，其实写什么都无所谓 jq中的 data可以是对象，也可以 a=1&amp;b=2这种形式都支持的 jq中除了$.ajax 除了这5个参数外，还有一些其他的参数属性名，如： timeout error beforeSend(比如：提交表单数据之前，可以先对数据进行格式验证) complete]]></content>
      <categories>
        <category>前端</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax超时怎么判断]]></title>
    <url>%2F2018%2F08%2F02%2Fajax%E8%B6%85%E6%97%B6%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[ajax超时判断 1234567891011121314151617var ajaxTimeoutTest = $.ajax(&#123; url: '', timeout: 1000, //超时时间设置，单位毫秒 type: 'get', // get post data: &#123;&#125;, dataType: 'json', //返回数据格式 success：function（data）&#123; alert（'成功'）; &#125;, complete: function(XMLHttpRequest, status) &#123; //请求完成后最终执行参数 if (status == 'timeout') &#123; //超时，status还有success，error等值的情况 ajaxTimeoutTest.abort(); alert('超时'); &#125; &#125;&#125;)；设置timeout的时间，通过检测complete时status的值判断请求是否超时，如果超时执行响应的操作。]]></content>
      <categories>
        <category>前端</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax简单介绍]]></title>
    <url>%2F2018%2F07%2F14%2Fajax%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[为什么需要ajax 本质：在不刷新页面的情况下，使用XMLHttpRequest对象进行异步的向服务器发送http请求，把请求回来的数据用来局部更新页面sync同步、async异步 异步的概念 从代码执行角度解释异步: 代码从上往下执行, 某些代码非常耗时, 导致后续代码迟迟不能执行, 这就是同步; 而如果某行代码比较特殊, 虽然耗时, 但不会阻塞, 这种代码运行方式就称为异步 同步会造成什么后果？ 同步如果阻塞了会造成假死的状态 异步代码典型案例 定时器setTimeout 特点：程序的执行顺序不依赖于程序的书写顺序，有可能比下面的代码晚完成 从生活中的例子来理解同步异步 同步：一直守在娃身边, 等娃醒来, 这个期间什么事情都不能做 —&gt; 页面假死状态 异步：在客厅玩一把王者荣耀, 娃醒来后会哭, 哭的话再去喂奶 理解为什么ajax中的XMLHttpRequest要设计成异步 因为网速可能比较慢，ajax请求数据不确定啥时候请求回来，在这个阶段如果是同步的等待则当前页面就会假死状态 使用异步对象发送get请求 先不考虑ajax,直接在地址栏访问validate.php来理解整个流程（/03-XMLHttpRequest-get/validate.php?username=jack） –&gt; 打开fiddler 参数在请求行当中 没有请求体 书写ajax代码 获取用户数据 让异步对象发送请求2.1 创建异步对象2.2 设置请求行 open(请求方式，请求url) get请求如果有参数就需要在url后面拼接参数 post如果有参数，就在请求体中传递2.3 设置请求头 setRequestHeader(‘key’,’value’) get方式不需要设置请求头content-type post需要设置content-type:application/x-www-form-urlencoded（这个是get请求与post请求的区别）2.4 设置请求体：发送请求 send(参数：key=value&amp;key=value) 如果有参数，post应该在这个位置传递参数 对于get请求不需要在这个位置传递参数 打开network 发现请求已经发送了，接下来我们要考虑的问题是通过什么办法来接收到请求回来的数据 使用异步对象发送接收响应 响应报文 报文行：响应状态码 响应状态信息 200 ok 报文头：服务器返回给客户端的一些额外信息 报文体：服务器返回给客户端的数据：responseText:普通字符串,responseXML:符合xml格式的字符串 要判断两个东西 readyState+status 在网上买东西 –&gt; 东西有货（status == 200）+快递到了可以去拿（readyState == 4） 一个真正成功的响应应该有两个方面：1.服务器成功响应 2.数据已经成功回到客户端并且可以使用了 status的值 0 什么都没发生 1 载入，已调用 send(),正在发送请求 2 载入完成，send()方法完成，已收到全部相应内容 3 解析，正在解析响应内容 4 完成，响应内容完成解析，可以在客户端调用了 从淘宝上买东西的角度把这整个的代码理解一下 12345678910var xhr = new XMLHttpRequest();xhr.open('get','./validate.php');//开始下单 我想去validate.php这个网店买东西，发货方式我选的是顺丰xhr.send(null);//没有额外的信息需要和老板沟通//下单完成之后，我继续上班，然后等快递xhr.onreadystatechange = function()&#123; //淘宝店有这个货 快递员打电话让我去拿 if(xhr.status == 200 &amp;&amp; xhr.readyState == 4)&#123; document.querySelector('.msg').innerHTML = xhr.responseText;//买到的东西 &#125;&#125; 使用异步对象发送post请求并接收响应 可以先在写ajax代码之前，写一个普通的post表单，然后打开fiddler看一下请求报文中的content-type和请求体的数据 与get的区别 xhr.setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoded’) xhr.send(请求体) 通过异步对象读取json文件生成动态页面结构 JSON.parse JSON.stringify XML语法介绍和XML文件的创建示例 xml 是一种数据格式，类似 json 一样，用来表示某一组数据(用数组)、一个对象(用对象) https://www.bejson.com/xml2json/（推荐用xml转json格式比较靠谱，用json转xml有点小问题） 通过异步对象读取XML文件并生成动态页面结构 querySelector querySelectorAll innerHTML jquery中的ajax介绍 介绍一个插件:jquery code snippet 常用属性 type url data dataType success 不常用的属性 timeout 超时时间 beforeSend 在发送之前如果使用return false则阻止ajax的发送（需要记住） error 报错的时候会触发 complete ajax结束的时候会触发（不管是成功还是失败都会触发） jq中其他ajax方法的介绍 推荐还是用$.ajax（用起来最灵活，因为我们可以设置beforeSend之类的属性） 简单的场景可以使用$.get,$.post]]></content>
      <categories>
        <category>前端</category>
        <category>ajax</category>
      </categories>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一锅炖总结]]></title>
    <url>%2F2018%2F07%2F06%2F%E4%B8%80%E9%94%85%E7%82%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[清除浮动 第一种方式： 12345678910.clearfix:after &#123; content: ""; display: block; height: 0; visibility: hidden; clear: both; &#125; .clearfix &#123; *zoom: 1; /*ie6,7 专门清除浮动的样式*/ &#125; 第二种方式： 123456789101112/*清除浮动的*/.clearfix:before,.clearfix:after &#123; content: ""; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 第三种： 1234&lt;div class="clear"&gt;&lt;/div&gt;.clear &#123; clear: both;&#125; 给父级元素添加 overflow:overflow: hidden 。。。。 文字图片对齐： vertical-align：middle;(默认值:baseline) 去除图片底侧空白： vertical-align：除baseline之外的几种模式均可 将img转化： display：block 文字溢出（…）显示： 强制换行： white-space: nowrap; 溢出隐藏： overflow: hidden; 隐藏部分省略号表示： text-overflow: ellipsis; ellipsis： 省略号… 盒子阴影：box-shadow: h-shadow v-shadow blur spread color 阴影; 水平距离 垂直距离 模糊距离 阴影尺寸 阴影颜色 内/外阴影 注意：默认是外阴影outset,因此外阴影是不需要写的，一旦写了可能会报错，但是切换为内阴影的时候，要加上inset CSS权重 标签名 权重值 ！important infinity正无穷 行间样式 1000 id 选择器 100 class 选择器、属性选择器、伪类选择器 10 标签选择器、伪元素选择器 1 通配符选择器 （* { }） 0 如果权重一样（优先级一样），会显示后面样式的，就是先来后到，谁在后面，谁（后面）就会覆盖前面的； 控制台常见的六种错误信息 EvalError：eval()的使用与定义不一致 // eval 是不被允许使用的 RangeError：数值越界 ReferenceError：非法或不能识别的引用数值 // 未经声明就使用，没有定义就使用 SyntaxError：发生语法解析错误 // Syntax 是语法解析（） TypeError：操作数类型错误 URIError：URI处理函数使用不当 // 引用地址错误 大部分都是3、4这种错误 举个小栗子： var 今天 = 123;这就是伪代码 var str = avs =&gt; ReferenceError]]></content>
      <categories>
        <category>前端</category>
        <category>一锅炖总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[跨域几种方式]]></title>
    <url>%2F2018%2F06%2F13%2F%E8%B7%A8%E5%9F%9F%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是跨域 一个域名组成： 协议(http://) 子域名 (www) . 主域名(xyz.com) : 端口号(8080) / 请求资源地址(scripts/jquery.js) javascript 处于安全考虑，不允许跨域调用其他页面的对象。 简单的讲，因为JavaScript同源策略的限制，a.com域名下的js无法操作b.com或是c.a.com域名下的对象。即：当协议、子域名，主域名、端口号中任意一个不相同时，都是不同域。不同域之间相互请求资源，就是’跨域’。 但是需要注意：跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了 跨域是由于收到了同源策略的限制，同源策略要求协议、域名、端口号完全一致才能正常通信。 特别注意：第一、 如果协议和端口造成的跨域问题，‘前台’无能为力。第二、 在跨域问题上，域仅仅是通过‘协议、域名、端口必须匹配’ 来识别而不会根据域名对应的IP地址是否相同来判断 什么是同源策略同源策略限制一个源加载的文档或者脚本如何与来自另一个源的资源进行交互。用于隔离潜在恶意文件的关键的安全机制。它的存在可以保护用户隐私信息，防止身份伪造等（读取cookie） 同源策略限制的内容： cookie、LocalStorage、IndexedDB等储存性内容 DOM节点 ajax请求不能发送 有三个标签是允许跨域加载资源的：123- &lt;img src="" alt=""&gt;- &lt;script src=""&gt;&lt;/script&gt;- &lt;link rel="stylesheet" href=""&gt; 处理跨域方法 JSONP 原理：利用&lt;script&gt;元素的这个开放策略，网页可以得到从其他来源动态产生的json数据。json请求需要对方的服务器做支持才可以； JSONP 发送的不是 Ajax 请求 缺点：不支持 Post 请求，仅支持get方法具有局限性； 优点： 兼容性好，可用于解决主流浏览器的跨域数据访问的问题。 CORS 原理：如果要启用 CORS 跨域资源共享，关键在于服务器端，只要服务器支持CORS跨域资源共享，则浏览器肯定能够正常访问 这种 CORS 接口；而且，客户端在发送 Ajax的时候，就像发送普通AJax一样，没有任何代码上的变化 发送的是ajax请求 支持ajax跨域 优点：功能更强大支持各种HTTP Method 缺点：CORS要求浏览器（IE&gt;10）和服务器同时支持，是跨域的根本解决方法，由浏览器自动完成，由此，兼容性不如 JSONP header(&quot; Access-Control-Allow-Origin:* &quot;); header(&quot; Access-Control-Allow-Methods:post,get &quot;); node搭建服务器（– 大胆的想法 –） 跨域只存在于浏览器之间，服务器之间不存在跨域之说，用node搭建本地服务器，ajax请求本地服务器，通过本地服务器去请求外部的接口]]></content>
      <categories>
        <category>前端</category>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式开发]]></title>
    <url>%2F2018%2F06%2F08%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[网页布局方式 固定宽度布局：为网页设置一个固定的宽度，通常以px做为长度单位，常见于PC端网页。 流式布局：为网页设置一个相对的宽度，通常以百分比做为长度单位。 栅格化布局：将网页宽度人为的划分成均等的长度，然后排版布局时则以这些均等的长度做为度量单位，通常利用百分比做为长度单位来划分成均等的长度。 响应式布局：通过检测设备信息，决定网页布局方式，即用户如果采用不同的设备访问同一个网页，有可能会看到不一样的内容，一般情况下是检测设备屏幕的宽度来实现。 注：以上几种布局方式并不是独立存在的，实际开发过程中往往是相互结合使用的。响应式布局 屏幕尺寸不一样展示给用户的网页内容也不一样，我们利用媒体查询可以检测到屏幕的尺寸（主要检测宽度），并设置不同的CSS样式，就可以实现响应式的布局。 一般我们会对常见的设备尺寸进行划分后，再分别确定为不同的尺寸的设备设计专门的布局方式，如下图所示： 类型 布局宽度 大屏幕 &lt;= 1200px 默认 &lt;= 980px 平板 &lt;= 768px 手机到平板 &lt;= 767px 手机 &lt;= 480px 以上是我们对常见的尺寸进行分类后的结果，下图是与之对应的媒体查询条件。 123456789101112131415/* 大屏幕 */@media (min-width: 1200px) &#123; ... &#125;/* 平板电脑和小平电脑之间额分辨率 */@media (min-width: 768px) and (max-width: 979px) &#123; ... &#125;/* 横向放置的手机和竖向放置的平板之间的分辨率 */@media (max-width: 767px) &#123; ... &#125;/* 横向放置的手机及分辨率更小的设备 */@media (max-width: 480px) 响应式开发 响应式开发的原理：媒体查询； 查询媒介，查询到当前屏幕(媒介媒体)的宽度，针对不同的屏幕宽度设置不同的样式来适应不同屏幕。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 实现方式：通过查询screen的宽度来指定某个宽度区间的网页布局。 超小屏幕 （移动设备） w&lt;768px 小屏设备 768px-992px 768 &lt;= w &lt;992 中等屏幕 992px-1200px 992 =&lt; w &lt;1200 宽屏设备 1200px以上 w&gt;=1200 媒体查询的基本实现方式：常用属性设置； http://www.runoob.com/cssref/css3-pr-mediaquery.html CSS 语法 12345@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125;你也可以针对不同的媒体使用不同 stylesheets :&lt;link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"&gt; 媒体类型 1234all 用于所有设备print 用于打印机和打印预览screen 用于电脑屏幕，平板电脑，智能手机等。speech 应用于屏幕阅读器等发声设备 媒体功能(最常用) device-width: 定义输出设备的屏幕可见宽度。 max-width : 定义输出设备中的页面最大可见区域宽度。 Bootstrap 简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。 来自 Twitter，粉丝众多，是目前最受欢迎的前端框架。 http://www.bootcss.com/ Amaze UI Amaze ~ 妹子UI，国人开发，后起之秀！ http://amazeui.org/ Bootstrap框架 Bootstrap框架：提高web开发效率 Bootstrap简介：当前最流行的前端UI框架(有预制界面组件), Bootstrap 是最受欢迎的 HTML、CSS 和 JS 框架，用于开发响应式布局、移动设备优先的 WEB 项目 Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷 Bootstrap是基于HTML5和CSS3开发的，它在jQuery的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分jQuery插件 BootStrap的版本了解: 2.x.x:兼容性好 / 代码不够简洁，功能不够完善 3.x.x:稳定性好,放弃了IE6-IE7,对IE8的支持一般 /偏向于响应式布局开发，移动设备优先的web项目开发 4.x.x:测试阶段，偏向于响应式，移动设备 BootStrap基本模板 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!--说明页面是html5页面--&gt;&lt;!DOCTYPE html&gt;&lt;!--页面使用的语言环境--&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;!--指定当前页面的字符编码--&gt; &lt;meta charset="utf-8"&gt; &lt;!--如果是IE，会使用最新的渲染引擎进行渲染--&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;!--标准的视口设置--&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=0"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap核心样式文件 --&gt; &lt;link href="../lib/bootstrap/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries: 这两个文件的引入是为了支持IE8下面的html5元素和媒体查询：因为在IE8下面默认不支持HTML5和媒体查询，所以需要引入两个插件--&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// 如果通过file://来查看文件，那么respond.js文件不能正常工作，说明必须在http://形式下访问才有用--&gt; &lt;!-- html5shiv.min.js：为了在IE8下面支持HTML标签 respond.min.js：为了在IE8下面支持媒体查询 --&gt; &lt;!--[if lt IE 9]&gt; &lt;!--只有IE9之前才会加载这两个文件 lt:less than--&gt; &lt;script src="../lib/html5shiv/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="../lib/respond.js/respond.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好，世界！&lt;/h1&gt;&lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) bootstrap是依赖jquery的--&gt;&lt;script src="../lib/jquery/jquery.js"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed bootstarp核心js文件--&gt; &lt;script src="../lib/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Bootstarp全局css样式 HTML5文档类型 移动设备优先 Normalize.css:为了增强跨浏览器表现的一致性，使用了 Normalize.css BootStrap版心容器—布局容器 i. 分类： .container 类用于固定宽度并支持响应式布局的容器。 .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 ii. 针对.container,当屏幕宽度&gt;992px的时候，布局容器宽度为1170px iii. 否则，当宽度&gt;768px的时候，布局容器宽度为970px iv. 当宽度&lt;768px的时候，布局容器宽度为100%(750px) BootStrap栅格系统 概念：Bootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中. “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）. 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局. 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding. 栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建. 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列. 栅格参数 栅格系统的意义：移动设备和桌面屏幕：它可以规范在不同尺寸的屏幕下，当前的列占据的宽度。或者说一行可以放置几个列. 12345678910111213141516&lt;!-- Stack the columns on mobile by making one full-width and the other half-width --&gt; &lt;div class="row"&gt; &lt;div class="col-xs-12 col-md-8"&gt;.col-xs-12 .col-md-8&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;/div&gt; &lt;!-- Columns start at 50% wide on mobile and bump up to 33.3% wide on desktop --&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;div class="col-xs-6 col-md-4"&gt;.col-xs-6 .col-md-4&lt;/div&gt; &lt;/div&gt; &lt;!-- Columns are always 50% wide, on mobile and desktop --&gt; &lt;div class="row"&gt; &lt;div class="col-xs-6"&gt;.col-xs-6&lt;/div&gt; &lt;div class="col-xs-6"&gt;.col-xs-6&lt;/div&gt; &lt;/div&gt; 细节 栅格系统是往上兼容的：意味着小屏幕上的效果在大屏幕上也是可以正常显示的人，但是大屏幕上的设置在小屏幕上却无法正常显示。 Row可以再次嵌套在列中。如果不能填满整列，则默认从左排列，如果超出，则换行展示 …..更多详情参考官网 LESSLESS 是动态的样式表语言，通过简洁明了的语法定义，使编写 CSS 的工作变得非常简单，本质上，LESS 包含一套自定义的语法及一个解析器 安装： 安装Nodejs环境 Node Package Manager (验证 node -v npm -v) npm:node packgemanager 打开控制台（cmd），执行npm install -g less (验证 lessc -v) node packet manager 命令行编译 lessc path/xxx.less path/xxx.css 编译 浏览器只能识别CSS，LESS只是用来提升CSS可维护性的一个工具，所最终需要将LESS编译成CSS，然而通过命令行编译效率比较低下，一般都会借助于编辑器来完成编译，以sublime_text为例，sublime_text默认并不支持LESS的编译操作，需要安装插件实现 语法 变量： 格式：@变量名: 值，定义完成后可以重复使用 1234@color: red; // 定义变量.nav &#123; color: @color; // 使用变量&#125; 混合 我们可以像使用函数一样来使用CSS 嵌套(我用的最多的，觉得很方便) 嵌套可以非常方便的管理我们的CSS层级关系 123456789.header &#123; height: 40px; nav &#123; overflow: hidden; a &#123; color: #666; &#125; &#125;&#125; 内容太多了，今天就到这里，碎觉。。。。。]]></content>
      <categories>
        <category>前端</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5]]></title>
    <url>%2F2018%2F05%2F28%2Fhtml5%2F</url>
    <content type="text"><![CDATA[HTML5中的一些新特性 用于绘画的canvas元素 用于媒介回放的video和audio元素 对本地离线存储的更好的支持 语义化标签 新的表单控件 如：data time email search 类样式操作 新增标签的兼容情况 IE9-IE10：浏览器不支持元素宽高，可以转化：display：block； IE8以下不认识H5新增标签，可以引入js文件，解决兼容问题（还可以动态创建H5新增标签，但是会比较的麻烦） 样式1234添加样式： add()移除类样式：remove()切换样式：toggle()判断是否包含某种类样式： constains() 自定义属性1234567规范：1.data-开头2.data-后必须至少有一个字符，多个单词使用-连接建议：1.名称该使用小写2.名称中不要任何的特殊字符3.名称不要使用纯数字 获取自定义属性1将data-后面的单词使用camel命名链接：必须使用camel合法取值，否则有可能无法获取 DOM扩展，获取元素的方式 document.querySelector(&#39;传入选择器名称&#39;) 123参数要求：传入id传感器，需要加入#；传入类选择器，需要加入点（.）只能获取单个元素，如果获取的元素不止一个，name只会返回第一个元素可传入后代选择器 document.querySelectorAll(&#39;传入选择器名称&#39;) 12获取满足条件的所有元素，返回伪数组改变子元素color，需要遍历数组 表单新增type属性email data range datatime ... oninput: 1监听当前指定元素的内容改变，只要内容改变（内容增加，内容删除）就会触发这个事件 ------针对内容 onvalid: 1当前验证不通过，就会触发 SessionStorage: 存储在本地，容量： 5MB左右 这个数据本质是存储在当前页面的内存中—意味着：在其他页面和浏览器无法获取数据 它的生命周期为当前页面关闭，关闭页面，数据会自动清除 setItem(key, value) 存储数据，以键值对的方式存储 getItem(key) 获取数据，通过指定名称获取对应的value值 removeItem(key) 删除数据，指定名称删除对应的数据 特别注意： 删除数据：在删除的时候，如果key错误，不会报错，但也不会删除数据 localStorage： 容量：20MB 不同浏览器不能共享数据，但是在同一浏览器的不同窗口中可以共享数据 生命周期： 永久有效：它的数据是存储在硬盘上的，并不会随着页面或者浏览器的关闭而清除，如果想要删除，必须手动清除 setItem() getItem() removeItem() clear() 清除所有内容 cookie、 sessionStorage 和 localStorage区别：- 相同点：都存储在客户端 - 不同点： 1. 存储大小 cookie数据大小不能超过4K； sessionStorage 和 localStorage虽然也有存储大小的限制，但比cookie大很多，可以达到5M或更大； 2. 有效时间 localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除； cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭； 3. 数据与服务器之间的交互方式 cookie 的数据会自动的传递到服务器，服务器端也可以写cookie到客户端 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存；]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS3动画]]></title>
    <url>%2F2018%2F05%2F06%2FCSS3%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[什么是CSS3中的动画？ 动画使元素从一种样式逐渐变化成为另外一种样式的效果 用表比分来规定变化发生的时间，或用关键词”from”和”to”，等同于0% 和 100% 0% 是动画的开始 100%是动画的完成 如果在CSS3中创建动画，需要用 @keyframes 规则创建动画 @keyframes 规定至少以下两项CSS3动画属性，即可将动画绑定到选择器： 规定动画的名称 规定动画的时长 写过的动画的小栗子： 动画的添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 100px; height: 100px; background-color: red; transform: translate(0,0) rotate(80deg); /*添加动画效果*/ /*1.animation-name:指定动画名称*/ animation-name: moveTest; /*2.设置动画的总耗时*/ animation-duration: 2s; /*3.设置动画的播放次数，默认为1次 可以指定具体的数值，也可以指定infinite(无限次)*/ animation-iteration-count: 1; /*4.设置交替动画 alternate:来回交替*/ animation-direction: alternate; /*5.设置动画的延迟*/ animation-delay: 0s; /*5.设置动画结束时的状态：默认情况下，动画执行完毕之后，会回到原始状态 forwards:会保留动画结束时的状态，在有延迟的情况下，并不会立刻进行到动画的初始状态 backwards:不会保留动画结束时的状态，在添加了动画延迟的前提下，如果动画有初始状态，那么会立刻进行到初始状态 both:会保留动画的结束时状态，在有延迟的情况下也会立刻进入到动画的初始状态*/ animation-fill-mode: both; /*6.动画的时间函数*/ animation-timing-function: linear; /*设置动画的播放状态 paused:暂停 running:播放*/ animation-play-state: running; /* animation: moveTest 2s linear 0s infinite alternate both; */ &#125; /*创建动画*/ @keyframes moveTest &#123; /*百分比是指整个动画耗时的百分比 10s*/ /*0%&#123; transform: translate(0,0); &#125;*/ /*from:0%*/ from&#123; transform: translate(0,0) rotate(45deg); &#125; /*0~1*/ 50%&#123; transform: translate(0,500px); &#125; /*1~2*/ /*100%&#123; transform: translate(500px,600px); &#125;*/ /*to:100%*/ to&#123; transform: translate(500px,600px); &#125; &#125;&lt;/style&gt; 1234567891011121314&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;input type="button" value="播放" id="play"&gt;&lt;input type="button" value="暂停" id="pause"&gt;&lt;script&gt; var div=document.querySelector("div"); document.querySelector("#play").onclick=function()&#123; div.style.animationPlayState="running"; &#125; document.querySelector("#pause").onclick=function()&#123; div.style.animationPlayState="paused"; &#125;&lt;/script&gt;&lt;/body&gt; 动画实现无缝连接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; *&#123; padding: 0; margin: 0; &#125; div&#123; width: 882px; height: 86px; margin:100px auto; background-color: #ddd; overflow: hidden; &#125; div &gt;ul&#123; width: 200%; list-style: none; /*1.设置的名称*/ animation-name: move; /*2.设置动画的耗时*/ animation-duration: 7s; /*3.市场无限循环*/ animation-iteration-count: infinite; /*4.设置时间函数*/ animation-timing-function: linear; &#125; div &gt; ul &gt; li&#123; width:126px; float: left; &#125; div &gt; ul &gt; li &gt; img&#123; width:100%; &#125; /*鼠标上移，停止动画*/ div:hover &gt; ul&#123; cursor: pointer; animation-play-state: paused; &#125; /*创建动画*/ @keyframes move &#123; from&#123; transform:translateX(0); &#125; to&#123; transform:translateX(-882px); &#125; &#125; // 这里如果换成 translateY(0) - translateY(..) 动画就是上下滚动&lt;/style&gt; 12345678910111213141516171819202122&lt;body&gt;&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="../images/1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/3.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/4.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/5.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/6.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/7.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/3.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/4.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/5.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/6.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="../images/7.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端-点透]]></title>
    <url>%2F2018%2F04%2F30%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E7%82%B9%E9%80%8F%2F</url>
    <content type="text"><![CDATA[什么是点透当A/B两个层上下z轴重叠，上层的A点击后消失或移开，并且B元素本身有默认click事件（如a标签）或绑定了click事件。在这种情况下，点击A/B重叠的部分，就会出现点透的现象。(来源于百度😂) 点透出现原因事件的触发顺序为: touchstart =&gt; touchmove =&gt; touchend =&gt; click 亦即click的触发是有延迟的，这个时间大概在300ms左右。 当手指触摸到屏幕的时候，系统生成两个事件，一个是touch 一个是click，touch先执行，touch执行完成后，A从DOM树上面消失了，而且由于移动端click还有延迟300ms左右的关系，当系统要触发click的时候，发现在用户点击的位置上面，目前离用户最近的元素是B，所以就直接把click事件作用在B元素上面了。 解决方式 方式一：使用github上的第三方开源fastclick库解决引入fastclick.js，原生js直接添加如下代码：123window.addEventListener( "load", function() &#123; FastClick.attach( document.body );&#125;, false ) jQuery或者zepto加上如下代码：123$(function() &#123;FastClick.attach(document.body);&#125;) require的话这样：12const FastClick = require('fastclick')FastClick.attach(document.body, options) 方法二：用touchend代替tap事件并阻止掉touchend的默认行为preventDefault() 1234$('ele').on('touchend', function(event) &#123; // TODO e.preventDefault()&#125;) 方法三： 延时300ms 12345$('ele').on('tap', function(event) &#123; setTimeout(() =&gt; &#123; // TODO &#125;, 340)&#125;) 注意: zepto 的tap事件是有点透问题的，但是最新版的zepto已经修复了这个问题。]]></content>
      <categories>
        <category>前端</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中操作数据库]]></title>
    <url>%2F2018%2F04%2F19%2FPHP%E4%B8%AD%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[PHP中数据库的增删改查12345678910111213141516查询： select * from mytable(默认无序) select * from mytable where id = 2 select * from mytable order by age desc（降序） select * from mytable limit4, 10(分页) select count(*) from mytable;（）分页的时候用的上 多表联合查询 用的最多的left join左边当主表， 右边当副表（连接id查询） select * from 左表 left join 右表 on 左表.cid = 右表.id;增加： insert into mytable values(null, ....) insert into mytable(字段1名， 字段2....)values(值....)删除： delete from mytable where id = ?修改： update mytable set age = 20, name = 'zs' where id = 2;]]></content>
      <categories>
        <category>PHP</category>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件冒泡与事件捕获]]></title>
    <url>%2F2018%2F04%2F02%2F%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7%2F</url>
    <content type="text"><![CDATA[事件冒泡与事件捕获 事件冒泡 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;!-- css样式 --&gt; &lt;style&gt; #box1 &#123; width: 400px; height: 400px; background-color: pink; &#125; #box2 &#123; width: 300px; height: 300px; background-color: skyblue; &#125; #box3 &#123; width: 200px; height: 200px; background-color: lightgray; &#125; &lt;/style&gt;&lt;body&gt; &lt;div id="box1"&gt; &lt;div id="box2"&gt; &lt;div id="box3"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;!-- javascript --&gt;&lt;script&gt; var box1 = document.getElementById('box1'); var box2 = document.getElementById('box2'); var box3 = document.getElementById('box3'); var arr = [box1, box2, box3]; for (var i = 0; i &lt; arr.length; i++) &#123; arr[i].addEventListener('click', function () &#123; console.log(this.id); &#125;, false); &#125; document.body.addEventListener('click', function () &#123; console.log('body'); &#125;, false); document.addEventListener('click', function () &#123; console.log('document'); &#125;, false);&lt;/script&gt; 12// addEventListener 的第三个参数为false的时候 ： 事件冒泡// 事件开始发生（从里向外）依次输出： box3 - box2 - box1 - body - document 事件捕获 12// addEventListener 的第三个参数为true 的时候 ： 事件捕获// 事件开始（从外向内进行捕获） 依次输出： document - body - box1 - box2 -box3 123456789101112131415// 注册事件三种方式：1.`onclick`:浏览器无法判断捕获阶段，因此只有冒泡阶段for (var i = 0; i &lt; arr.length; i++)&#123; arr[i].onclick = function () &#123; console.log(this.id); &#125;&#125;2.`attachEvent`：两个参数，浏览器无法判断捕获阶段，只有冒泡阶段for (var i = 0; i &lt; arr.length; i++)&#123; arr[i].attachEvent('click', function ()&#123; console.log(this.id); &#125;);&#125;3.`addEventListener`:有三个参数 当第三个参数为false时，事件冒泡； :第三个参数是true时，事件捕获； 事件三个阶段 捕获阶段 ： 由外向内 当前目标阶段 冒泡阶段 ： 由内向外 浏览器执行原理：先执行捕获状态，从最外层向最里层去执行，捕获在冒泡之前 e 事件参数：当事件发生的时候，可以获取一些和事件相关的数据； e.target 是真正触发事件的对象但在老版本IE中，获取事件对象的方式是： window.evente.target 和 this的区别 e.target 是指从哪里冒出来的那个元素（当前元素最深处） this：事件执行者e.target 和 e.currentTarget e.target：获取真正触发事件的对象 e.currentTarget：事件处理函数所处的对象 e.eventPhase 属性可以查看事件触发时所处的阶段阻止事件冒泡的方式： 标准方式: event.stopPropagation() IE低版本：event.cancleBubble() = true;标准中已经废弃事件三要素： 事件源：触发事件的元素 事件名称： 事件处理函数：事件触发后要执行的代码（函数形式）阻止默认行为 event.preventDefault()； return false() 注意： 在jQuery中，return false()可以阻止事件冒泡]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链|原型]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型 定义：原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该对象产生的对象，可以继承该原型的属性和方法。原型也是对象； 利用原型特点和概念，可以提取共有属性； 对象如何查看原型 ==&gt; 隐式属性 __proto__ 对象如何查看对象的构造函数 ==&gt; constructor 原型链]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型链|原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div居中方式]]></title>
    <url>%2F2018%2F03%2F04%2Fdiv%E5%B1%85%E4%B8%AD%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[div居中方式第一种方式： flex方式实现居中 这些属性要放在居中元素的父元素上。 display:flex; align-items: center; justify-content: center; align-items: center; justify-content设置主轴(x轴)对齐方式 align-items设置侧轴(y轴)对齐方式1234567891011121314151617181920212223&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;// &lt;!-- style样式 --&gt;&lt;style&gt; .wrapper &#123; width: 400px; height: 400px; border: 1px solid #ccc; display: flex; align-items: center; justify-content: center; &#125; .demo &#123; width: 200px; height: 200px; background-color: pink; &#125;&lt;/style&gt; 第二种方式： 这两个属性要放在居中元素的父级上，块级元素设置两个参数： height line-height会使块元素内部的含有行级元素特点的元素(这个元素身上有vertical-algin: middle;属性)垂直水平居中 height = line-height; text-align: center;123456789101112131415161718192021222324&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;// &lt;!-- style样式 --&gt;&lt;style&gt; .wrapper &#123; width: 400px; height: 400px; border: 1px solid #ccc; line-height: 400px; text-align: center; &#125; .demo &#123; width: 200px; height: 200px; background-color: pink; display: inline-block; vertical-align: middle; &#125;&lt;/style&gt; 第三种方式： 此方法适用于固定宽高的元素 这些属性要作用在居中的元素本身 绝对定位要注意父级的定位 position: absolute; top: 50%; left: 50%; margin-top: -(高度的一半); margin-left: -(宽度的一半);1234567891011121314151617181920212223242526&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;// &lt;!-- style样式 --&gt;&lt;style&gt; .wrapper &#123; width: 400px; height: 400px; border: 1px solid #ccc; position: relative; &#125; .demo &#123; width: 200px; height: 200px; background-color: pink; position: absolute; top: 50%; left: 50%; margin-top: -100px; mix-blend-mode: -100px; &#125;&lt;/style&gt; 第四种方式： 非固定宽高 这些属性要作用在居中的元素本身 绝对定位要注意父级的定位 position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);12345678910111213141516171819202122232425&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;// &lt;!-- style样式 --&gt;&lt;style&gt; .wrapper &#123; width: 400px; height: 400px; border: 1px solid #ccc; position: relative; &#125; .demo &#123; width: 200px; height: 200px; background-color: pink; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;&lt;/style&gt; 第五种方式： 不确定宽高的情况 这些属性要作用在居中的元素本身 绝对定位要注意父级的定位 position: ansolute; top: 0; left: 0; right: 0; margin: auto;123456789101112131415161718192021222324252627&lt;body&gt; &lt;div class="wrapper"&gt; &lt;div class="demo"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;// &lt;!-- style样式 --&gt;&lt;style&gt; .wrapper &#123; width: 400px; height: 400px; border: 1px solid #ccc; position: relative; &#125; .demo &#123; width: 200px; height: 200px; background-color: pink; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: 0; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝与浅拷贝]]></title>
    <url>%2F2018%2F03%2F03%2F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[浅拷贝 1234567891011121314151617181920212223&lt;script&gt; var obj1 = &#123; name: '金毛', age: 20, sex: '男', dog: &#123; name: '大黄', age: 2, sex: 'male' &#125; &#125; var obj2 = &#123;&#125;; for (var key in obj1) &#123; obj2[key] = obj1[key]; &#125; obj1.name = '我变变' obj1.dog.name = '狗狗变' console.log(obj1); console.log(obj2)&lt;/script&gt; 浅拷贝只拷贝对象的第一层属性, 第一层属性中有某个属性是复杂数据类型，会拷贝复杂数据类型的引用地址 dog是对象 是复杂类型，因此，值会被修改 输出结果如图： 深拷贝 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; var obj1 = &#123; name: '金毛', age: 20, sex: '男', dog: &#123; name: '大黄', age: 2, sex: 'male' &#125;, friends: ['1', '2', '3'] &#125; var obj2 = &#123;&#125;; function deepCopy(o1, o2) &#123; for(var key in o1) &#123; if(o1[key] instanceof Array) &#123; o2[key] = []; deepCopy(o1[key], o2[key]); &#125; else if (o1[key] instanceof Object) &#123; o2[key] = []; deepCopy(o1[key], o2[key]); &#125; else &#123; o2[key] = o1[key]; &#125; &#125; &#125; deepCopy(obj1, obj2); obj1.name = '我变变' obj1.dog.name = '狗狗变' obj1.friends = ['敬', '自', '己'] console.log(obj1); console.log(obj2)&lt;/script&gt; 输出结果如图： 注意：Object可以理解为是所有对象的祖宗，因此，在判断的时候，需要先判断是不是数组，再判断是不是对象，顺序不能反; 深拷贝，是拷贝对象各个层级的属性 总结： 复杂数据之间的相互赋值，就是用等号(=)进行相互赋值的时候，是引用地址的赋值； 拷贝指的是把它的属性和方法全部取出来复制一遍，然后放到一个全新的看起来一模一样的对象中； 深拷贝和浅拷贝是对象拷贝的两种手段 浅拷贝的话，复制出来的新的对象只能拷贝原对象的第一层属性，如果第一层属性里面有某个属性是复杂数据类型，浅拷贝只是将复杂数据类型的引用地址拷贝过去； 深拷贝会利用递归的原理一层一层的将对象各个层级的属性都拷贝出来]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单介绍cookie与session]]></title>
    <url>%2F2018%2F02%2F07%2F%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8Dcookie%E4%B8%8Esession%2F</url>
    <content type="text"><![CDATA[cookie 与 session session: 安全 理论上容量没有限制 放在服务器端 在一定时间内保持在服务器(有效时间：大约30分钟) 对于安全要求的，如：购物车，个人中心，登录信息； cookie： 不安全 容量上4KB左右 放在客户端 对于安全无要求可以采用，例如360浏览器的换肤； 状态保持（两种）： 无状态：无记忆能力 有状态: 有记忆能力 会话： 网页打开不关闭（举个栗子：电话不挂断，处于保持状态） http协议是无状态的协议http协议自身不对请求和响应之间的通信状态进行保存一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接 http 与 https http： 默认端口： 80 https： 默认端口： 443 更安全 但是比http慢2到100倍 状态码识别 1XX information(信息性状态码) – 接收的请求正在处理 2XX success(成功状态码) – 请求正常处理完毕 200 – OK 204 – No Content (请求处理成功没有资源返回) 3XX redirect(重定向状态码) – 需要附加操作已完成请求 301 – Moved Permanently 比如指定的资源路径最后忘记加’/‘,可能会导致301状态http://example.com/sample 303 – See Other303状态码明确表示客户端应该采用GET方式获取资源 4XX ClientError(客户端状态码错误) – 服务器无法请求处理 400 – Bad Request该状态码表示请求报文中存在语法错误 403 – Forbidden该状态码表示对请求资源的访问被拒绝了 404 – Not Found该状态码表示服务器上无法找到请求的资源 5XX server Error(服务器错误状态码) – 服务器处理请求出错 服务器本身出现了问题]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>cookie,session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rem与em的使用]]></title>
    <url>%2F2018%2F01%2F14%2Frem%E4%B8%8Eem%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132 &lt;style&gt; html &#123; font-size: 20px; &#125; .box &#123; /* width: 100px; height: 100px;*/ width: 10em; height: 10em; background-color: red; font-size: 18px; /*1em=16 18/16 em*/ &#125; .parent &#123; width: 10rem; height: 10rem; background-color: blue; font-size: 12px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; 写一些字 &lt;/div&gt; &lt;div class="parent"&gt; 也写一些字 &lt;/div&gt;&lt;/body&gt; em:就是一种长度单位，它是参照当前元素的字号，如果没有设置，就参照父容器或者当前浏览器的默认字号 rem是css3新增的一种长度单位，它是参照根元素(html)的字号]]></content>
      <categories>
        <category>前端</category>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象-递归-闭包]]></title>
    <url>%2F2018%2F01%2F05%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E9%80%92%E5%BD%92-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[面向对象的三大特性： 封装 继承 什么是继承？ 继承是面向对象最显著的一个特性。继承是从已有的类中派生出新的类，新的类能吸收已有类的数据属性和行为，并扩展出新的能力； js中的继承： 体现在构造函数与构造函数之间 实例成员的继承(借用构造函数)： Person.call(this, name, age, sex) 公共方法的继承(使用原型继承): Student.prototype = new Person() 继承有几种方式？ 原型继承 构造函数继承 组合继承 … 多态: 是一种编程思想，不存在完全的面向对象，写代码的时候都是面向对象与面向过程结合 闭包：概念：在一个作用域中可以访问另一个局部作用域中的变量(属性)时，就称这种现象是闭包 特点：被引用的变量不会自动释放，会一直占用内存空间 优点：延展作用域范围 递归 什么是递归？ 函数自己调用自己就是递归 特别注意： 递归一定要有一个结束的条件 典型例子： 斐波那契数列 函数 函数的创建方式： var fn = function() { } function fn() { } var fn = new Function(‘console.log(12)’) 函数中this的指向： 普通函数中: window 构造函数: 当前的实例对象 计时器: window 事件执行函数: 触发事件的DOM元素对象 bind call: 第一个参数 高阶函数： 把函数作为参数：setTimeOut 把函数作为返回值：bind 函数的方法： bind: 返回一个新的函数 作用：改变this指向 call: 立即执行调用call方法的函数 作用：改变this指向 apply: 立即执行apply方法的函数 作用：改变this指向 只有两个参数： 第一个参数：改变this指向 第二个参数：数组]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面向对象,递归,闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2018%2F01%2F04%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[我的第一篇博客 好记性不如烂笔头，记录一些东西，便于后期查看… 这是我第一篇博客，庆祝一下，写一个js版本的HelloWorld 1console.log("Hello World!");]]></content>
      <categories>
        <category>Hello World</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>
